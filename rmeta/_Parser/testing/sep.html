<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<title>Generalized Quantifiers</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="robots" content="noarchive" />
<style type="text/css">
<!--
body {background-color: white}
td.brownbox { background: #fafbdd; color: gray; font-size: x-small; width:90px}
table.whitebox { background: white; color: black; width:60px; margin:10px}
td.note {color: gray; font-size:small}
p.center {text-align: center}
table.center {margin-left: auto; margin-right: auto}
div.center {text-align: center}
A.plain:link {text-decoration: none}
A.plain:visited {text-decoration: none}
A.plain:active {text-decoration: none}
h4.center {text-align: center}
A.banner:link {color: red}
A.banner:visited {color: red}
A.banner:active {color: red}
#message { background: #fafbdd; color: red; text-align: center; align: center }
-->
</style>
</head>

<body>

<table width="100%" cellpadding="5">

<tr>
<td align="center" valign="middle" class="brownbox">version history<br />

 <table border="1" cellpadding="2" cellspacing="4" class="whitebox">
 <tr>
 <td align="center"><a href="http://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=generalized-quantifiers" class="plain">HOW TO CITE<br />THIS ENTRY</a></td>
 </tr>
 </table>
</td>

<td align="center">
<h4 class="center"><a href="/" class="plain">Stanford Encyclopedia of Philosophy</a></h4>

 <a href="../../contents.html#a" class="plain">A</a> |
 <a href="../../contents.html#b" class="plain">B</a> |
 <a href="../../contents.html#c" class="plain">C</a> |
 <a href="../../contents.html#d" class="plain">D</a> |
 <a href="../../contents.html#e" class="plain">E</a> |
 <a href="../../contents.html#f" class="plain">F</a> |
 <a href="../../contents.html#g" class="plain">G</a> |
 <a href="../../contents.html#h" class="plain">H</a> |
 <a href="../../contents.html#i" class="plain">I</a> |
 <a href="../../contents.html#j" class="plain">J</a> |
 <a href="../../contents.html#k" class="plain">K</a> |
 <a href="../../contents.html#l" class="plain">L</a> |
 <a href="../../contents.html#m" class="plain">M</a> |
 <a href="../../contents.html#n" class="plain">N</a> |
 <a href="../../contents.html#o" class="plain">O</a> |
 <a href="../../contents.html#p" class="plain">P</a> |
 <a href="../../contents.html#q" class="plain">Q</a> |
 <a href="../../contents.html#r" class="plain">R</a> |
 <a href="../../contents.html#s" class="plain">S</a> |
 <a href="../../contents.html#t" class="plain">T</a> |
 <a href="../../contents.html#u" class="plain">U</a> |
 <a href="../../contents.html#v" class="plain">V</a> |
 <a href="../../contents.html#w" class="plain">W</a> |
 <a href="../../contents.html#x" class="plain">X</a> |
 <a href="../../contents.html#y" class="plain">Y</a> |
 <a href="../../contents.html#z" class="plain">Z</a>

<br />
<br />
 <table border="0">
 <tr>
 <td align="center" class="note">This document uses XHTML/Unicode to format the display. If you think special symbols are not displaying correctly, see our guide <a href="../../special-characters.html" class="plain">Displaying Special Characters</a>.</td>
 </tr>
 </table>
</td>

<td align="center" valign="middle" class="brownbox">last substantive content change<br />

 <table border="1" cellpadding="2" cellspacing="4" class="whitebox">
 <tr>
 <td align="center" valign="middle">DEC<br />
 5<br />
 2005<br /></td>
 </tr>
 </table>
</td>
</tr>
</table>

<!--FUNDING MESSAGE-->
<div id="message">
  <a href="../../fundraising/" class="banner">
  The Encyclopedia Now Needs Your Support<br />
  Please Read How You Can Help Keep the Encyclopedia Free</a>
</div>

<!--FUNDING MESSAGE-->

<hr />

<h1>Generalized Quantifiers</h1>

<p>

Generalized quantifiers are now standard equipment in the toolboxes of
both logicians and linguists. The purpose of this entry is to describe
these tools: where they come from, how they work, and what they can be
used to do. The description is by necessity sketchy, but more
comprehensive surveys exist in the literature and will be referred to
when needed. To fully appreciate the text below, one will need basic
familiarity with elementary set theoretic terminology, and with the
language of first-order logic.</p>

<ul>
<li><a href="#prel">1. Preliminaries</a></li>
<li><a href="#aris">2. Aristotle</a></li>
<li><a href="#freg">3. Frege</a></li>
<li><a href="#univ">4. Generalizing the universal and existential quantifier</a></li>
<li><a href="#arbi">5. Generalized quantifiers of arbitrary type</a></li>
<li><a href="#topi">6. Topic neutrality</a></li>
<li><a href="#rela">7. Relativization</a></li>
<li><a href="#expr">8. Expressive power</a></li>
<li><a href="#comp">9. Generalized quantifiers and computation</a></li>
<li><a href="#natu">10. Generalized quantifiers and natural language</a></li>
<li><a href="#cons">11. Conservativity</a></li>
<li><a href="#exte">12. Extension</a></li>
<li><a href="#dete">13. Determiners that are not <font size="-1">ISOM</font></a></li>
<li><a href="#othe">14. Other quantifier expressions in natural language</a></li>
<li><a href="#Bib">Bibliography</a></li>
<li><a href="#Oth">Other Internet Resources</a></li>
<li><a href="#Rel">Related Entries</a></li>
</ul>

<hr />

<h2><a name="prel">1. Preliminaries</a></h2>

<p>

The term &ldquo;generalized quantifier&rdquo; 
reflects that these
entities were introduced in logic as generalizations of the standard
quantifiers of modern logic, &forall; and 
 &exist;.<sup>[<a href="notes.html#1" name="note-1">1</a>]</sup> 
 In retrospect one may say that &forall; and &exist; have been found
to be just two instances of a much more general concept of quantifier,
making the term &ldquo;generalized&rdquo; 
superfluous. Today it is
also common to use just
&ldquo;quantifier&rdquo;
for the general
notion, but &ldquo;generalized quantifier&rdquo;
is still frequent for
historical reasons. This article reflects both uses, with a tendency
to insert
&ldquo;generalized&rdquo;
in logical contexts, and drop it in linguistic contexts.</p>

<p>

It is useful to distinguish <em>quantifier expressions</em> from what
they signify or denote, the (generalized) quantifiers themselves. In
logical languages, quantifier expressions are variable-binding
operators. Thus, &exist; is the familiar operator such that in a
formula &exist;<em>x</em>&phi;, &exist;<em>x</em> binds all free
occurrences of <em>x</em> in &phi;. It signifies the quantifier
&lsquo;there exists&rsquo; &mdash; we'll see shortly exactly what this
object is. Likewise, the symbol <em>Q</em><sub>0</sub> is often used
as a variable-binding operator signifying &lsquo;there exist
infinitely many&rsquo;.</p>

<p>

In natural languages a variety of expressions have been seen as
quantifier expressions, for example, each of the following English
expressions:
 <font face="arial, helvetica" size="-1">everything</font>,
 <font face="arial, helvetica" size="-1">nothing</font>,
 <font face="arial, helvetica" size="-1">three books</font>,
 <font face="arial, helvetica" size="-1">the ten professors</font>,
 <font face="arial, helvetica" size="-1">John</font>,
 <font face="arial, helvetica" size="-1">John and Mary</font>,
 <font face="arial, helvetica" size="-1">only John</font>,
 <font face="arial, helvetica" size="-1">firemen</font>,
 <font face="arial, helvetica" size="-1">every</font>,
 <font face="arial, helvetica" size="-1">at least five</font>,
 <font face="arial, helvetica" size="-1">most</font>,
 <font face="arial, helvetica" size="-1">all but ten</font>,
 <font face="arial, helvetica" size="-1">less than half of the</font>,
 <font face="arial, helvetica" size="-1">John's</font>,
 <font face="arial, helvetica" size="-1">some student's</font>,
 <font face="arial, helvetica" size="-1">no _ except Mary</font>,
 <font face="arial, helvetica" size="-1">more male than female</font>,
 <font face="arial, helvetica" size="-1">usually</font>,
 <font face="arial, helvetica" size="-1">never</font>,
 <font face="arial, helvetica" size="-1">each  other</font>.<sup>[<a href="notes.html#2" name="note-2">2</a>]</sup></p>

<p>

What, then, are generalized quantifiers? Before answering that
question, a brief historical prelude is enlightening.</p>

<h2><a name="aris">2. Aristotle</a></h2>

<p>

Aristotle not only invented logic but also introduced the study of
quantification as a main part of the discipline. The syllogistics can
be seen as a formal study of the meaning of the four basic quantifier
expressions 
 <font face="arial, helvetica" size="-1">all</font>,
 <font face="arial, helvetica" size="-1">no</font>,
 <font face="arial, helvetica" size="-1">some</font>,
 <font face="arial, helvetica" size="-1">not all</font>,
 and of their properties. For example, the
validity, according to Aristotle, of the syllogism</p>

<blockquote>
<table>
<tr>
<td><font face="arial, helvetica" size="-1">all(A,B)<br />all(B,C)</font></td>
</tr>

<tr>
<td><hr /></td>
</tr>

<tr>
<td><font face="arial, helvetica" size="-1">some(A,C)</font></td>
</tr>
</table>
</blockquote>

<p>

shows that he considered, in contrast with modern logical usage,
 <font face="arial, helvetica" size="-1">all</font>
 to have <em>existential import</em>, so that
 <font face="arial, helvetica" size="-1">all A are B</font>
 entails that
 <font face="arial, helvetica" size="-1">A</font>
 is not an empty term. Likewise, the validity of the
syllogism</p>

<blockquote>
<table>
<tr>
<td><font face="arial, helvetica" size="-1">some(A,B)<br />all(B,C)</font></td>
</tr>

<tr>
<td><hr /></td>
</tr>

<tr>
<td><font face="arial, helvetica" size="-1">some(A,C)</font></td>
</tr>
</table>
</blockquote>

<p>
 
expresses that
 <font face="arial, helvetica" size="-1">some</font>
 is <em>monotone increasing</em> (as we now put it) in the second
argument. Each valid syllogism formalizes part of the meaning of these
quantifier expressions, but Aristotle's study of their properties went
beyond the syllogistics. He observed, for example, that <font
face="arial, helvetica" size="-1">some</font> and <font face="arial,
helvetica" size="-1">no</font> are <em>convertible</em> or, as we
might now say, <em>symmetric</em>, since they satisfy the scheme</p>

<blockquote>
<table>
<tr>
<td><font face="arial, helvetica" size="-1">Q(A,B)</font></td>
</tr>

<tr>
<td><hr /></td>
</tr>

<tr>
<td><font face="arial, helvetica" size="-1">Q(B,A)</font></td>
</tr>
</table>
</blockquote>

<p> 

in contrast with
 <font face="arial, helvetica" size="-1">all</font>
 and
 <font face="arial, helvetica" size="-1">not all</font>.
 Further, he studied how various forms of <em>negation</em> combined
with quantifier expressions in (what was later called) <em>the square
of
 opposition</em>.<sup>[<a href="notes.html#3" name="note-3">3</a>]</sup> 
 The circumstance that the syllogistic format in itself is too weak to
express interesting pieces of reasoning, and that generations of
philosophers nonetheless mechanically continued to present it as the
essence of logic far into the 20th century, should not obscure the
fact that Aristotle's logic is a decisive contribution to the study of
quantification.</p>

<p>

Especially interesting in the present context is the fact that these
quantifier expressions take <em>two</em> arguments or terms, and thus
can be seen as <em>binary relations</em>, both syntactically (as
Aristotle no doubt saw them) and semantically: given that terms
signify sets of individuals, the expression
 <font face="arial, helvetica" size="-1">some</font>
 can be taken to signify the relation 
of overlap, i.e., of having non-empty intersection, between two sets,
and
 <font face="arial, helvetica" size="-1">all</font>
 signifies the inclusion relation. Note that these are not relations
between individuals but between sets of individuals &mdash;
<em>second-order</em> relations. Indeed, they are exactly the
generalized quantifiers <em>some</em> and <em>all</em>, respectively
(on a given universe).</p>

<p>

This thread &mdash; that quantifier expressions signify second-order
relations &mdash; was not picked up by any of Aristotle's medieval
followers (as far as we know). Instead, they picked up on the fact
that the two terms have different status: the first combines with the
quantifier expression to form a noun phrase (as we now say), which is
the <em>subject</em> of the sentence, whereas the second is a verb
phrase constituting the <em>predicate</em>. This led them to focus on
what the subject &mdash;
 <font face="arial, helvetica" size="-1">all men</font>,
 <font face="arial, helvetica" size="-1">some dogs</font>,
 <font face="arial, helvetica" size="-1">no sailors</font>
 &mdash; signified, which conceptually seems to be a harder
question. One might surmise that
 <font face="arial, helvetica" size="-1">all men</font>
 signifies every man (or the set of men), and that
 <font face="arial, helvetica" size="-1">some dogs</font>
 signifies some particular dog, but what about
 <font face="arial, helvetica" size="-1">no sailors</font>?
 In fact, one can show that approaches like these are doomed to
 failure.<sup>[<a href="notes.html#4" name="note-4">4</a>]</sup>
 The modern solution is that noun phrases signify
<em>sets of sets</em> of individuals, so that, for example
 <font face="arial, helvetica" size="-1">some dogs</font>
 signifies the set of sets containing at least one dog &mdash; but
that appears to require a more abstract and mathematical approach to
semantics than the idea, which is at least implicit in Aristotle, that
quantifier phrases signify relations between (the denotations of)
terms.</p>

<h2><a name="freg">3. Frege</a></h2>

<p>

The second major historical contribution to the theory of generalized
quantifiers came from the &lsquo;inventor&rsquo; of modern logic,
Gottlob Frege, in the 1870s. In fact, Frege's contribution is twofold.
As every philosophy student knows, he introduced the language of
predicate logic, with sentential connectives, identity, and the
variable-binding operators &forall; and &exist; (in modern notation,
not Frege's). These are the quantifiers that logicians during the
1950s began to &lsquo;generalize&rsquo;. But Frege also explicitly
formulated the abstract notion of a quantifier as a second-order
relation, or, as he called it, a <em>second level concept</em>
(&ldquo;Begriff zweiter Stufe&rdquo;).
He was well aware that the four
Aristotelian quantifiers were prime examples, but he wanted to avoid
the focus on subject-predicate form, which he (with much
justification) saw as having been a major obstacle to the development
of logic after Aristotle. It was therefore an important discovery that
these quantifiers could all be defined in terms of &forall; and
sentential operators (replacing
 <font face="arial, helvetica" size="-1">all</font>(<em>A</em>,
 <em>B</em>) by &forall;<em>x</em>(<em>A</em>(<em>x</em>) &rarr;
<em>B</em>(<em>x</em>)),
 <font face="arial, helvetica" size="-1">some</font>(<em>A</em>,
 <em>B</em>) by &not;&forall;<em>x</em>(<em>A</em>(<em>x</em>) &rarr;
&not;<em>B</em>(<em>x</em>)), etc.).</p>

<p>

In fact, the only difference between Frege's notion of a second-level
concept and the modern notion of a generalized quantifier is that
Frege did not have the idea of an <em>interpretation</em> or
<em>model</em>, which we now (since the advent of model theory in the
1950s) see as a <em>universe</em> that the quantifiers range over,
plus an assignment of suitable semantic objects to the non-logical
symbols. Frege's symbols all had fixed meanings, and the only universe
he considered was the totality of everything. But apart from this, one
may well say that it was Frege who discovered generalized
quantifiers. This aspect of Frege's logic, however, remained in the
background for a long time, and model theorists in the 50s and 60s
seem not to have been aware of it.</p>

<h2><a name="univ">4. Generalizing the universal and existential quantifier</a></h2>

<p>

Modern predicate logic fixes the meaning of &forall; and &exist; with
the respective clauses in the truth definition, which specifies
inductively the conditions under which a formula
&phi;(<em>y</em><sub>1</sub>,&hellip;,<em>y</em><sub><em>n</em></sub>)
(with at most
<em>y</em><sub>1</sub>,&hellip;,<em>y</em><sub><em>n</em></sub> free)
is <em>satisfied</em> by corresponding elements
<em>b</em><sub>1</sub>,&hellip;,<em>b</em><sub><em>n</em></sub> in a
model <strong>M</strong> = (<em>M</em>, <em>I</em>) (where <em>M</em> is the
universe and <em>I</em> the interpretation function assigning suitable
extensions to non-logical symbols): 
 <strong>M</strong> <img alt="models" src="models.gif" />
&phi;(<em>b</em><sub>1</sub>,&hellip;,<em>b</em><sub><em>n</em></sub>). The
clauses are</p>

<ol>

<li><strong>M</strong> <img alt="models" src="models.gif" /> 
 &forall;<em>x</em>&psi;(<em>x</em>, <em>b</em><sub>1</sub>,&hellip;,<em>b</em><sub><em>n</em></sub>)
 iff for each <em>a</em> &isin; <em>M</em>,
 <strong>M</strong> <img alt="models" src="models.gif" /> 
 &psi;(<em>a</em>, <em>b</em><sub>1</sub>,&hellip;,
<em>b</em><sub><em>n</em></sub>)</li>

<li><strong>M</strong> <img alt="models" src="models.gif" /> 
 &exist;<em>x</em>&psi;(<em>x</em>, <em>b</em><sub>1</sub>,&hellip;,
<em>b</em><sub><em>n</em></sub>) iff there is some <em>a</em> &isin;
<em>M</em> s. t. <strong>M</strong> 
 <img alt="models" src="models.gif" />
&psi;(<em>a</em>, <em>b</em><sub>1</sub>,&hellip;,
<em>b</em><sub><em>n</em></sub>)</li></ol>

<p>

To introduce other quantifiers, one needs to appreciate what kind of
expressions &forall; and &exist; are. Syntactically, they are
operators binding one variable in one formula. To see how they work
semantically it is useful to rewrite (1) and (2) slightly. First,
every formula &psi;(<em>x</em>) with one free variable denotes in a
model <strong>M</strong> a subset of <em>M</em>; the set of individuals in
<em>M</em> satisfying &psi;(<em>x</em>). More generally, if
&psi;(<em>x</em>,
<em>y</em><sub>1</sub>,&hellip;,<em>y</em><sub><em>n</em></sub>) =
&psi;(<em>x</em>,[<em>y</em>]) has at most the free variables shown
and [<em>b</em>] =
<em>b</em><sub>1</sub>,&hellip;,<em>b</em><sub><em>n</em></sub> are
elements of <em>M</em>, let</p>

<blockquote>

&psi;(<em>x</em>,[<em>b</em>])<sup><strong>M</strong>, <em>x</em></sup>
= {<em>a</em> &isin; <em>M</em> : <strong>M</strong> 
 <img alt="models" src="models.gif" />
&psi;(<em>a</em>,[<em>b</em>])}</blockquote>

<p> 

be the <em>extension</em> of &psi;(<em>x</em>,[<em>y</em>]) in
<strong>M</strong> relative to <em>b</em><sub>1</sub>,&hellip;,
<em>b</em><sub><em>n</em></sub>. Then we can reformulate (1) and (2)
as follows:</p>

<ol start="3">
<li>
 <strong>M</strong> <img alt="models" src="models.gif" /> 
&forall;<em>x</em>&psi;(<em>x</em>,[<em>b</em>]) iff
&psi;(<em>x</em>,[<em>b</em>])<sup><strong>M</strong>,<em>x</em></sup>
= <em>M</em></li>

<li>
 <strong>M</strong> <img alt="models" src="models.gif" />
 &exist;<em>x</em>&psi;(<em>x</em>,[<em>b</em>]) iff &psi;(<em>x</em>,[<em>b</em>])<sup><strong>M</strong>,<em>x</em></sup> &ne;
&empty;</li></ol>

<p>
 
Thus, the conditions on the right hand side emerge as <em>properties
of the sets</em> &psi;(<em>x</em>,[<em>b</em>]). In fact, we
can think of &forall; and &exist; as denoting these properties, i.e.,
the property of being identical to the universe, and of being
non-empty, respectively. And now it is easy to think of other
properties of sets that can also be treated as quantifiers, for
example, the property of containing at least 5, or exactly 3,
elements, or of being
 infinite.<sup>[<a href="notes.html#5" name="note-5">5</a>]</sup></p>
 
<p>

Note that these properties depend only on the universe <em>M</em>,
not on the rest of the model. Extensionally, they are simply sets of
subsets of <em>M</em>. This leads to the following definition.
essentially from Mostowski (1957):</p>

<blockquote>

<strong>Definition</strong>: A generalized quantifier <em>Q</em> of
type &lt;1&gt; is
<ol start="5">

<li>syntactically, a variable-binding
operator such that whenever &phi; is a formula so is
<em>Qx</em>&phi;, and <em>Qx</em> binds all free occurrences of
<em>x</em> in &phi;;</li>

<li>semantically, a mapping from arbitrary
universes (non-empty sets) <em>M</em> to a set <em>Q</em><sub><em>M</em></sub>
of subsets of <em>M</em>, which interprets formulas of the form
<em>Qx</em>&phi; according to the clause</li>

<li><strong>M</strong> <img alt="models" src="models.gif" /> 

<em>Qx</em>&psi;(<em>x</em>,[<em>b</em>]) iff 
&psi;(<em>x</em>,[<em>b</em>])<sup><strong>M</strong>,<em>x</em></sup> &isin;
<em>Q</em><sub><em>M</em></sub></li>
</ol>
</blockquote>

<p>

 Here we use the same symbol for the quantifier expression and the
mapping that it signifies or denotes. Thus, &forall; is now taken to
denote the universal quantifier, also written &forall;, which is the
mapping given by</p>

<blockquote>

&forall;<sub><em>M</em></sub> = {<em>M</em>}</blockquote>

<p> 

for all <em>M</em>. Similarly, &exist; denotes the mapping defined
by</p>

<blockquote>

&exist;<sub><em>M</em></sub> = {<em>A</em> &sube; <em>M</em> :
<em>A</em> &ne; &empty; }</blockquote>

<p>

And here are some other generalized quantifiers:</p>

<ol start="8">

<li>(&exist;<sub>&ge; 5</sub>)<sub><em>M</em></sub> = {<em>A</em> &sube;
<em>M</em> : |<em>A</em>| &ge; 5} (|<em>X</em>| is the size or
cardinality of <em>X</em>)<br />
 (&exist;<sub>=3</sub>)<sub><em>M</em></sub> = {<em>A</em> &sube;
<em>M</em> : |<em>A</em>| = 3}<br />
 (<em>Q</em><sub>0</sub>)<sub><em>M</em></sub> = {<em>A</em> &sube;
<em>M</em> : <em>A</em> is infinite}<br />
 (<em>Q</em><sup><em>R</em></sup>)<sub><em>M</em></sub> = {<em>A</em> &sube;
<em>M</em> : |<em>A</em>| &gt; |<em>M</em> &minus; <em>A</em>|} (the
&ldquo;Rescher quantifier&rdquo;)<br />
 (<em>Q</em><sub>even</sub>)<sub><em>M</em></sub> = {<em>A</em> &sube;
<em>M</em> : |<em>A</em>| is even}<br /></li></ol>

<p>

We now have a precise notion of a generalized quantifier, of which
&forall; and &exist; are instances, along with infinitely many others.
Moreover, we see how to extend first-order logic <em>FO</em> to a
logic <em>FO</em>(<em>Q</em>), by adding the clause (5) to the
formation rules, and the clause (7) to the truth definition.
Similarly, if we add more than one generalized quantifier:
<em>FO</em>(<em>Q</em><sub>1</sub>,&hellip;,<em>Q</em><sub><em>n</em></sub>).</p>

<p>

In such a logic one may be a able to say things that are not
expressible in <em>FO</em>. For example, it is well-known that in
<em>FO</em> the notion of finiteness cannot be expressed. Thus there is
no way to say, of an ordering relation &lt;, that each element has only
finitely many predecessors, for instance. But this is just the sort of
thing one can express in <em>FO</em>(<em>Q</em><sub>0</sub>):</p>

<ol start="9">

<li>&forall;<em>x</em> &not;<em>Q</em><sub>0</sub><em>y</em>(<em>y</em>
&lt; <em>x</em>)</li></ol>

<p>

Likewise, one cannot say in <em>FO</em> that a (finite) set
<em>A</em> contains exactly half of the elements of the universe
<em>M</em>, but that is expressible in
<em>FO</em>(<em>Q</em><sup>R</sup>):</p>

<ol start="10">

<li>&not;<em>Q</em><sup><em>R</em></sup><em>x</em> <em>A</em>(<em>x</em>) 
 <img alt="and" src="wedge.jpg" />
&not;<em>Q</em><sup><em>R</em></sup><em>x</em>
 &not;<em>A</em>(<em>x</em>)</li>
</ol>

<p>

(The first conjunct says that |<em>A</em>| &le; |<em>M</em> &minus;
<em>A</em>|, and the second that |<em>M</em> &minus; <em>A</em>| &le;
|<em>A</em>|.)</p>

<h2><a name="arbi">5. Generalized quantifiers of arbitrary types</a></h2>

<p>

Further generalization is possible. First, we can let <em>Q</em> bind
one variable in two or more formulas. Second, we can let it
simultaneously bind two or more variables in (some of) these formulas.
The <em>typing</em> of <em>Q</em> indicates this: <em>Q</em> is of type
&lt;<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt;
(where each <em>n</em><sub><em>i</em></sub> is a natural number &ge; 1) if it
applies to <em>k</em> formulas, and binds <em>n</em><sub><em>i</em></sub>
variables in the <em>i</em>th formula. This explains why the
quantifiers in the previous section were said to be of type
&lt;1&gt;.</p>

<p>

In the general case, one normally chooses distinct variables
<em>x</em><sub><em>i</em>1</sub>,&hellip;,
<em>x</em><sub><em>i</em><em>n</em><sub><em>i</em></sub></sub> =
[<em>x</em><sub><em>i</em></sub>] for 1 &le; <em>i</em> &le;
<em>k</em>, so that a formula beginning with <em>Q</em> has the form</p>

<ol start="11">

<li><em>Q</em>[<em>x</em><sub>1</sub>],&hellip;,[<em>x</em><sub><em>k</em></sub>]
(&phi;<sub>1</sub>,&hellip;,&phi;<sub><em>k</em></sub>)</li></ol>

<p>

where all free occurrences of
<em>x</em><sub><em>i</em>1</sub>,&hellip;,<em>x</em><sub><em>i</em><em>n</em><sub><em>i</em></sub></sub>
in &phi;<sub><em>i</em></sub> become bound. Now <em>Q</em> associates
with each universe <em>M</em> a <em>k</em>-ary relation
<em>Q</em><sub><em>M</em></sub> between relations over <em>M</em>,
where the <em>i</em>th argument is an
<em>n</em><sub><em>i</em></sub>-ary relation between individuals. The
corresponding clause in the truth definition becomes</p>

<ol start="12">

<li><strong>M</strong>
 <img alt="models" src="models.gif" />
 <em>Q</em>[<em>x</em><sub>1</sub>],&hellip;,[<em>x</em><sub><em>k</em></sub>]
(&psi;<sub>1</sub>([<em>x</em><sub>1</sub>],[<em>b</em>]),&hellip;,&psi;<sub><em>k</em></sub>([<em>x</em><sub><em>k</em></sub>],[<em>b</em>]))
iff <br />
<em>Q</em><sub><em>M</em></sub>(&psi;<sub>1</sub>([<em>x</em><sub>1</sub>],[<em>b</em>])<sup><strong>M</strong>,[<em>x</em><sub>1</sub>]</sup>,&hellip;,&psi;<sub><em>k</em></sub>([<em>x</em><sub><em>k</em></sub>],[<em>b</em>]
)<sup><strong>M</strong>,[<em>x</em><sub><em>k</em></sub>]</sup>)</li></ol>

<p>

 Here
&psi;<sub><em>i</em></sub>([<em>x</em><sub><em>i</em></sub>],[<em>y</em>])
is a formula with at most the free variables shown, [<em>b</em>] is a
sequence of elements of <em>M</em> corresponding to [<em>y</em>], and
&psi;<sub><em>i</em></sub>([<em>x</em><sub><em>i</em></sub>],[<em>b</em>])<sup><strong>M</strong>,[<em>x</em><sub><em>i</em></sub>]</sup>
is the extension of &psi;<sub><em>i</em></sub>([<em>x</em><sub><em>i</em></sub>],[<em>y</em>]) in <strong>M</strong>
relative to [<em>b</em>] , i.e., the set of
<em>n</em><sub><em>i</em></sub>-tuples
[<em>a</em><sub><em>i</em></sub>] such that <strong>M</strong>
 <img alt="models" src="models.gif" />
 &psi;<sub><em>i</em></sub>([<em>a</em><sub><em>i</em></sub>],[<em>b</em>]).</p>

<p>

This is the official concept of a generalized quantifier in this
article. It was introduced by Lindstr&ouml;m (1966), and these
quantifiers are sometimes called
&ldquo;Lindstr&ouml;m 
 quantifiers&rdquo;.<sup>[<a href="notes.html#6" name="note-6">6</a>]</sup>
 If we fix <em>M</em> to the universe containing
&lsquo;everything&rsquo;, we essentially have Frege's notion of a
second-level 
 concept.<sup>[<a href="notes.html#7" name="note-7">7</a>]</sup></p>

<p>

<em>Q</em> is <em>monadic</em> if on each universe <em>M</em> it is a
relation between subsets of <em>M</em>, i.e., if its type is
&lt;1,&hellip;,1&gt;; otherwise it is <em>polyadic</em>. For
example, the Aristotelian quantifiers mentioned earlier are of type
&lt;1,1&gt;:</p>

<ol start="13">

<li><a name="qlist2"></a>
<em>all</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; <em>A</em> &sube;
<em>B</em>
<br />
 <em>some</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; <em>A</em> &cap;
<em>B</em> &ne; &empty;
<br />
 <em>no</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; <em>A</em> &cap;
<em>B</em> = &empty;
<br />
 <em>not all</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; <em>A</em>
 <img src="not-subseteq.jpg" alt="not a subset of" />
  <em>B</em>
 <sup>[<a href="notes.html#8" name="note-8">8</a>]</sup></li></ol>

<p>

Here are some more type &lt;1,1&gt; quantifiers:</p>

<ol start="14">

<li>
 (<em>at least five</em>)<sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &cap; <em>B</em>| &ge; 5
<br />
 (<em>exactly three</em>)<sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &cap; <em>B</em>| = 3
<br />
(<em>infinitely many</em>)<sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr;
<em>A</em> &cap; <em>B</em> is infinite
<br />
<em>most</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &cap; <em>B</em>| &gt; 
|<em>A</em> - 
 <em>B</em>|<sup>[<a href="notes.html#9" name="note-9">9</a>]</sup>
<br />
(<em>an even number of</em>)<sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &cap; <em>B</em>| is even
<br />
<em>MO</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em>| &gt; |<em>B</em>|
<br />
<em>I</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em>| = |<em>B</em>| 
(the &ldquo;H&auml;rtig quantifier&rdquo;)</li></ol>

<p>

With monadic quantifiers it is convenient to use just <em>one</em> variable,
and let <em>Q</em> bind that same variable in each of the formulas.
Thus, to say that most <em>A</em>s are not <em>B</em>, for example, one
may write</p>

<blockquote><em>most</em>
<em>x</em>(<em>A</em>(<em>x</em>),&not;<em>B</em>(<em>x</em>))</blockquote>

in the corresponding logical language, rather than <em>most</em> <em>x</em>,
<em>y</em>(<em>A</em>(<em>x</em>),&not;<em>B</em>(<em>y</em>)). 

<p>

Here are a few polyadic quantifiers:</p>

<ol start="15">

<li>
<table>
<tr>
 <td width="70%"><em>W</em><sub><em>M</em></sub>(<em>R</em>) &hArr; <em>R</em>
is a well-ordering of <em>M</em></td>
 <td width="5%">&nbsp;</td>
 <td width="25%" valign="top">type &lt;2&gt;</td>
</tr>

<tr>
 <td width="70%">(<em>Q</em><sub>0</sub><sup><em>n</em></sup>)<sub><em>M</em></sub>(<em>R</em>) &hArr; <br />
 &nbsp; &nbsp; there is an infinite <em>A</em> &sube; <em>M</em> s.t.
 <em>A</em><sup><em>n</em></sup> &sube; <em>R</em></td>
 <td width="5%">&nbsp;</td>
 <td width="25%" valign="top">type &lt;<em>n</em>&gt;</td>
</tr>

<tr>
 <td width="70%"><em>Res</em><sup><em>k</em></sup>(<em>most</em>)<sub><em>M</em></sub>(<em>R</em>, <em>S</em>) &hArr; 
|<em>R</em> &cap; <em>S</em>| &gt; |<em>R</em> - <em>S</em>|</td>
 <td width="5%">&nbsp;</td>
 <td width="25%" valign="top">type &lt;<em>k</em>,<em>k</em>&gt;</td>
</tr>

<tr>
 <td width="70%"><em>RECIP</em><sub><em>M</em></sub>(<em>A</em>,
 <em>R</em>) &hArr; <br /> 
 &nbsp; &nbsp; for
all distinct <em>a</em>, <em>b</em> &isin; <em>A</em> there is
<em>n</em> &ge; 1 and
<em>c</em><sub>0</sub>,&hellip;,<em>c</em><sub><em>n</em></sub> s.t.
 <br /> &nbsp; &nbsp; 
<em>c</em><sub>0</sub> = <em>a</em> and
<em>c</em><sub><em>n</em></sub> = <em>b</em> and
<em>c</em><sub><em>i</em></sub><em>Rc</em><sub><em>i</em>+1</sub> for
<em>i</em> &lt; <em>n</em></td>
 <td width="5%">&nbsp;</td>
 <td width="25%" valign="top">type &lt;1,2&gt;</td>
</tr>
</table>

</li>
</ol>

<p>

<em>W</em> and <em>Q</em><sub>0</sub><sup><em>n</em></sup> come from
logic and set theory.
<em>Res</em><sup><em>k</em></sup>(<em>most)</em> is the
<em>resumption</em> of <em>most</em> to <em>k</em>-tuples. Resumption
can be applied to any quantifier (in the syntax, this means replacing
each individual variable by a corresponding <em>k</em>-tuple of
variables); it has logical uses but also, like <em>RECIP</em>, uses in
the interpretation of certain sentences in natural languages; see
 <a href="#othe">Section 14</a>
 below.</p>

<h2><a name="topi">6. Topic neutrality</a></h2>

<p>

Both Mostowski and Lindstr&ouml;m had one additional condition in
their definitions of generalized quantifiers: they should not
distinguish isomorphic models. Informally, they are
<em>topic-neutral</em>: the truth of a statement of the form
&phi; = <em>Qx</em>, <em>yz</em>(<em>A</em>(<em>x</em>),
<em>R</em>(<em>y</em>, <em>z</em>)), say, in a model <strong>M</strong>
doesn't depend on the particular individuals <em>M</em> consists
of. If the individuals of <em>M</em> are mapped in a one-one fashion
onto the individuals of another universe
 <em>M&prime;</em>, and if
<em>A</em> and <em>R</em> are mapped accordingly, one obtains an
<em>isomorphic</em> model <strong>M</strong>&prime;.  <em>Isomorphism
closure</em> then says that <strong>M</strong> <img alt="models"
src="models.gif" /> &phi; iff <strong>M</strong>&prime; 
 <img alt="models" src="models.gif" /> &phi; .</p>

<p>

More formally, if <strong>M</strong> = (<em>M</em>, <em>I</em>) and
<strong>M</strong>&prime; = (<em>M&prime;</em>, <em>I&prime;</em>) are models
for the same vocabulary <em>V</em> of non-logical symbols, <em>f</em>
is an isomorphism from <strong>M</strong> to <strong>M</strong>&prime;, iff</p>

<ul>

<li><em>f</em> is a bijection (a one-one onto function) from <em>M</em>
to <em>M&prime;</em>;
</li>

<li>whenever <em>P</em> is an <em>n</em>-ary predicate symbol in
<em>V</em> and
<em>a</em><sub>1</sub>,&hellip;,<em>a</em><sub><em>n</em></sub> &isin;
<em>M</em>, <br />
(<em>a</em><sub>1</sub>,&hellip;,<em>a</em><sub><em>n</em></sub>)
&isin; <em>I</em>(<em>P</em>) iff
(<em>f</em>(<em>a</em><sub>1</sub>),&hellip;,<em>f</em>(<em>a</em><sub><em>n</em></sub>))
&isin; <em>I&prime;</em>(<em>P</em>);</li>

<li>whenever <em>c</em> is an individual constant in <em>V</em>,
<em>I&prime;</em>(<em>c</em>) = <em>f</em>(<em>I</em>(<em>c</em>)).</li>
</ul>

<p>

<strong>M</strong> and <strong>M</strong>&prime; are <em>isomorphic</em>, in symbols,</p>

<blockquote><strong>M</strong> <img alt="isomorphic" src="cong.jpg" />
<strong>M</strong>&prime;</blockquote>

<p>

if there is an isomorphism from one to the other. Now if <em>Q</em> is
a generalized quantifier of type
&lt;<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt;,
<em>P</em><sub><em>i</em></sub> is an
<em>n</em><sub><em>i</em></sub>-ary predicate symbol for 1 &le;
<em>i</em> &le; <em>k</em>, <strong>M</strong> = (<em>M</em>, <em>I</em>) is a model for the vocabulary
{<em>P</em><sub>1</sub>,&hellip;,<em>P</em><sub><em>k</em></sub>}, and
<em>R</em><sub><em>i</em></sub> =
<em>I</em>(<em>P</em><sub><em>i</em></sub>), we also write</p>

<blockquote><strong>M</strong> = (<em>M</em>, <em>R</em><sub>1</sub>,&hellip;,
<em>R</em><sub><em>k</em></sub>)</blockquote>

<p>

Then <em>Q</em> satisfies <em>isomorphism closure</em>, or just
 <font size="-1">ISOM</font>, if the following holds:</p>

<ol start="16">

<li>If (<em>M</em>,
<em>R</em><sub>1</sub>,&hellip;,<em>R</em><sub><em>k</em></sub>)
 <img alt="isomorphic" src="cong.jpg" />
 (<em>M&prime;</em>,
<em>R&prime;</em><sub>1</sub>,&hellip;,<em>R&prime;</em><sub><em>k</em></sub>),
then<br />
<em>Q</em><sub><em>M</em></sub>(<em>R</em><sub>1</sub>,&hellip;,<em>R</em><sub><em>k</em></sub>)
&hArr;
<em>Q</em><sub><em>M&prime;</em></sub>(<em>R&prime;</em><sub>1</sub>,&hellip;,
<em>R&prime;</em><sub><em>k</em></sub>).</li></ol>
 

<p>

One easily checks that all the generalized quantifiers exemplified so
far are indeed
 <font size="-1">ISOM</font>.
 We did not include this
requirement in the definition of generalized quantifiers however,
since there are natural language quantifiers that do not satisfy it;
see below. But logic is supposed to be topic-neutral, so
 <font size="-1">ISOM</font>
 is almost always imposed. Then two important things follow. First, as
indicated above, sentences in logical languages do not distinguish
isomorphic models. More precisely, we have the following</p>

<blockquote>

<strong>FACT</strong><br />
If <em>L</em> =
<em>FO</em>(<em>Q</em><sub>1</sub>,&hellip;,<em>Q</em><sub><em>n</em></sub>),
each <em>Q</em><sub><em>i</em></sub> is
 <font size="-1">ISOM</font>, 
&phi; is an <em>L</em>-sentence, and <strong>M</strong> 
<img alt="isomorphic" src="cong.jpg" /> <strong>M</strong>&prime;, then <strong>M</strong> 
 <img alt="models" src="models.gif" /> &phi; &hArr; <strong>M</strong>&prime; 
 <img alt="models" src="models.gif" /> &phi;.

</blockquote>

<p>

Second,
 <font size="-1">ISOM</font>
 takes a particularly interesting form for <em>monadic</em>
quantifiers. If <strong>M</strong> = (<em>M</em>,
<em>A</em><sub>1</sub>,&hellip;,<em>A</em><sub><em>k</em></sub>),
where <em>A</em><sub><em>i</em></sub> &sube; <em>M</em> for each
<em>i</em>, then
<em>A</em><sub>1</sub>,&hellip;,<em>A</em><sub><em>k</em></sub>
partition <em>M</em> into 2<sup><em>k</em></sup> pairwise disjoint
subsets (some of which may be empty); let us call them the
<em>parts</em> of <strong>M</strong> . We illustrate with <em>k</em> =
2 and <strong>M</strong> = (<em>M</em>, <em>A</em>, <em>B</em>):</p>

<blockquote>
 <img alt="Figure 1" src="Fig1.jpg" height="148" width="153" /><br />
 <em>Figure 1</em>
</blockquote>

<p>

Now it is not hard to see that only the <em>sizes of the parts</em> determine
whether two models of this kind are isomorphic or not:</p>

<blockquote>

<strong>FACT</strong>
<br /> (<em>M</em>,
<em>A</em><sub>1</sub>,&hellip;,<em>A</em><sub><em>k</em></sub>)
 <img alt="isomorphic" src="cong.jpg" />
 (<em>M&prime;</em>,
<em>A&prime;</em><sub>1</sub>,&hellip;,<em>A&prime;</em><sub><em>k</em></sub>)
 iff the cardinalities of the
corresponding parts are the same.

</blockquote>

<p>

This shows that monadic and
 <font size="-1">ISOM</font>
 generalized quantifiers indeed deal only with <em>quantities</em>,
i.e., with <em>sizes</em> of sets rather than the sets themselves. The
list (14) of type &lt;1,1&gt; generalized quantifiers clearly
illustrates this, but also the Aristotelian quantifiers can be
formulated in terms of cardinalities,</p>

<blockquote>
<em>all</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &minus; <em>B</em>| = 0 
<br />
<em>some</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; 
|<em>A</em> &cap; <em>B</em>| &gt; 0
</blockquote>

<p>

etc., and similarly for the type &lt;1&gt; examples we gave.</p>

<h2><a name="note">7. Relativization</a></h2>

<p>

Every statement involving a generalized quantifier <em>Q</em> takes
place within some universe <em>M</em>. Sometimes it is useful to be
able to mirror this relativization to a universe <em>inside</em>
<em>M</em>.  This means defining a new quantifier with one extra set
argument which says that <em>Q</em> behaves on the universe restricted
to that argument exactly as it behaves on <em>M</em>. Thus, if
<em>Q</em> is of type
&lt;<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt;,
we define <em>Q</em><sup>rel</sup> of type &lt;1,<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt; as
follows:</p>

<ol start="17">

<li>(<em>Q</em><sup>rel</sup>)<sub><em>M</em></sub>(<em>A</em>,
<em>R</em><sub>1</sub>,&hellip;,<em>R</em><sub><em>n</em><sub><em>k</em></sub></sub>)
&hArr;<sub>def</sub>
<em>Q</em><sub>A</sub>(<em>R</em><sub>1</sub><img src="restriction.jpg" alt="restricted to" /><em>A</em>,&hellip;,<em>R</em><sub><em>n</em><sub><em>k</em></sub></sub><img src="restriction.jpg" alt="restricted to" /><em>A</em>) 
</li>

</ol>

<p>

where <em>R</em><sub><em>i</em></sub> &sube;
<em>M</em><sup><em>n</em><sub><em>i</em></sub></sup> and
<em>R</em><sub><em>i</em></sub><img src="restriction.jpg" alt="restricted to" /><em>A</em> is the
restriction of <em>R</em><sub><em>i</em></sub> to <em>A</em>, i.e.,
the set of <em>n</em><sub><em>i</em></sub>-tuples in
<em>R</em><sub><em>i</em></sub> &cap;
<em>A</em><sup><em>n</em><sub><em>i</em></sub></sup>.</p>

<p>

We have in fact already seen several examples of relativization:
since one easily verifies (see the lists (8) and (14)) that</p>

<ol start="18">
<li><em>all</em> = &forall;<sup>rel</sup>
<br />
 <em>some</em> = &exist;<sup>rel</sup>
<br />
 <em>at least five</em> = (&exist;<sub>&ge;5</sub>)<sup>rel</sup>
<br />
 <em>exactly three</em> = (&exist;<sub>=3</sub>)<sup>rel</sup>
<br />
 <em>infinitely many</em> = (<em>Q</em><sub>0</sub>)<sup>rel</sup>
<br />
 <em>most</em> = (<em>Q</em><sup><em>R</em></sup>)<sup>rel</sup>
<br />
 <em>an even number of</em> = (<em>Q</em><sub>even</sub>)<sup>rel</sup>
<br />
</li></ol>

<h2><a name="expr">8. Expressive power</a></h2>

<p>

We described how generalized quantifiers can be added to <em>FO</em>,
resulting in more expressive logics. A <em>logic</em> in this sense
roughly consist of a set of sentences, a class of models, and a truth
relation (or a satisfaction relation) between sentences and models.
Such logics are often called <em>model-theoretic logics</em>, since
they are defined semantically in terms of models and truth, rather
than proof-theoretically in terms of a deductive system for
 deriving
 theorems.<sup>[<a href="notes.html#10" name="note-10">10</a>]</sup>
 Here we restrict attention to logics of the form
<em>FO</em>(<em>Q</em><sub>1</sub>, <em>Q</em><sub>2</sub>,&hellip;),
formed by adding generalized quantifiers to <em>FO</em>, where each
quantifier comes with a formation rule and a semantic clause for the
truth definition as described in
 <a href="#arbi">Section 5</a>
 above.</p>

<p>

There is an obvious way to compare the expressive power of
model-theoretic logics. <em>L</em><sub>2</sub> is at least as
expressive as <em>L</em><sub>1</sub>, in symbols,</p>

<blockquote><em>L</em><sub>1</sub> &le;
<em>L</em><sub>2</sub></blockquote>

if every <em>L</em><sub>1</sub>-sentence &phi; is <em>logically
equivalent</em> to some <em>L</em><sub>2</sub>-sentence &psi;, i.e.,
&phi; and &psi; are true in the same models. Also,
<em>L</em><sub>1</sub> and <em>L</em><sub>2</sub> have the <em>same
expressive power</em>, <em>L</em><sub>1</sub> &equiv;
<em>L</em><sub>2</sub>, if <em>L</em><sub>1</sub> &le;
<em>L</em><sub>2</sub> and <em>L</em><sub>2</sub> &le;
<em>L</em><sub>1</sub>, and <em>L</em><sub>2</sub> is stronger than
<em>L</em><sub>1</sub>, <em>L</em><sub>1</sub> &lt;
<em>L</em><sub>2</sub>, if <em>L</em><sub>1</sub> &le;
<em>L</em><sub>2</sub> but <em>L</em><sub>2</sub> 
 <img src="not-leq.jpg" alt="not less than or equal to" />
 <em>L</em><sub>1</sub>. Thus, <em>L</em><sub>1</sub> &lt;
<em>L</em><sub>2</sub> if everything that can be said in
<em>L</em><sub>1</sub> can also be said in <em>L</em><sub>2</sub>, but
there is some <em>L</em><sub>2</sub>-sentence which is not equivalent
to any sentence in <em>L</em><sub>1</sub>. 

<p>

How does one establish facts about expressive power? It seems as if
in order to show <em>L</em><sub>1</sub> &le; <em>L</em><sub>2</sub> one
has to go through all of the infinitely many sentences in
<em>L</em><sub>1</sub> and for each one find an equivalent in
<em>L</em><sub>2</sub>. But in practice it suffices to show that the
generalized quantifiers in <em>L</em><sub>1</sub> are definable in
<em>L</em><sub>2</sub>. If <em>Q</em> is of type &lt;1, 2&gt; ,
say, <em>Q</em> is <em>definable</em> in <em>L</em><sub>2</sub> if there is an
<em>L</em><sub>2</sub>-sentence &psi; whose non-logical vocabulary
consists exactly of one unary and one binary predicate symbol, such
that for all models <strong>M</strong> = (<em>M</em>, <em>A</em>,
<em>R</em>),</p>

<blockquote><em>Q</em><sub><em>M</em></sub>(<em>A</em>, <em>R</em>) &hArr;
(<em>M</em>, <em>A</em>, <em>R</em>) 
 <img alt="models" src="models.gif" /> &psi;</blockquote>

<p>

Similarly for other types. For example, the quantifier <em>all</em> is
definable in <em>FO</em>, since the following holds:</p>

<blockquote><em>all</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr; (<em>M</em>,
<em>A</em>, <em>B</em>) 
 <img alt="models" src="models.gif" />
&forall;<em>x</em>(<em>A</em>(<em>x</em>) &rarr;
<em>B</em>(<em>x</em>))</blockquote>

Likewise, <em>Q<sup>R</sup></em> is definable in
<em>FO</em>(<em>most)</em>, since 

<blockquote>(<em>Q<sup>R</sup></em>)<sub><em>M</em></sub>(<em>A</em>) &hArr;
(<em>M</em>, <em>A</em>, <em>B</em>) <img alt="models" src="models.gif" /> <em>most
x</em>(<em>x</em> = <em>x</em>, <em>A</em>(<em>x</em>))</blockquote>

<p>

(note that all our logics contain the logical apparatus of <em>FO</em>,
so they are all extensions of <em>FO</em>). The latter is an instance
of the following observation:</p>

<ol start="19">

<li>For any generalized quantifier <em>Q</em>, <em>Q</em> is
definable in <em>FO</em>(<em>Q</em><sup>rel</sup>).</li>
</ol>

<p>

Such facts about definability can be easy or hard to
 establish,<sup>[<a href="notes.html#11" name="note-11">11</a>]</sup>
 but they suffice to establish positive facts about expressivity,
since we have the readily verified</p>

<blockquote>

<strong>FACT</strong><br />
<em>FO</em>(<em>Q</em><sub>1</sub>,&hellip;,<em>Q</em><sub><em>n</em></sub>)
&le; <em>L</em> if and only if each <em>Q</em><sub><em>i</em></sub> is
definable in <em>L</em>.

</blockquote>

<p>

On the other hand, to prove <em>inexpressibility</em>, i.e., that some
sentence is <em>not</em> equivalent to any <em>L</em>-sentence, is harder. One
way that sometimes works is to establish that <em>L</em><sub>1</sub>
has some property that <em>L</em><sub>2</sub> lacks; then one might be
able to conclude that <em>L</em><sub>1</sub> 
 <img src="not-leq.jpg" alt="not less than or equal to" />
 <em>L</em><sub>2</sub>. Some properties that are typical of
<em>FO</em>, but fail for most stronger logics, are:</p>

<ul>

<li>The <em>L&ouml;wenheim property</em>: If a sentence is true in
some infinite model, it is also true in some countable model.</li>

<li>The <em>Tarski property</em>: If a sentence is true in some
countably infinite model, it is also true in some uncountable
model.</li>

<li>The <em>compactness property</em>: If no model makes every element
of the set of sentences &Phi; true, then there is a finite subset
&Psi; of &Phi; such that no model makes every sentence in &Psi;
true.</li>

<li>The <em>completeness property</em>: The set of valid sentences is
recursively enumerable (i.e., can be generated by some formal
system).</li></ul>

<p>

For example, <em>FO</em>(<em>Q</em><sub>0</sub>) does not have the
compactness
 property.<sup>[<a href="notes.html#12" name="note-12">12</a>]</sup>
 This can be seen by looking at the set of sentences</p>

<blockquote>&Phi; = {&not;<em>Q</em><sub>0</sub><em>x</em>(<em>x</em>
= <em>x</em>)} &cup; {<em>&theta;</em><sub><em>n</em></sub> :
<em>n</em> = 1,2,&hellip;}</blockquote>

where <em>&theta;</em><sub><em>n</em></sub> is an <em>FO</em>-sentence
saying that there are at least <em>n</em> elements in the universe. If
you take any finite subset &Phi;&prime; of &Phi; , and <em>M</em> is a
universe whose cardinality is the largest <em>n</em> such that
<em>&theta;</em><sub><em>n</em></sub> belongs to &Phi;&prime;, then
all sentences in &Phi;&prime; are true in <em>M</em>. But no universe
can make all sentences in &Phi; true. And this shows that
<em>Q</em><sub>0</sub> is not definable in <em>FO</em>, i.e., that
<em>FO</em>(<em>Q</em><sub>0</sub>) 
 <img src="not-leq.jpg" alt="not less than or equal to" />
  <em>FO</em>, since
otherwise we could replace &Phi; by an equivalent set of
<em>FO</em>-sentences, but <em>FO</em> does have the compactness
property, so that it impossible.

<p>

However, this way of proving inexpressibility only works for logics
with properties like those above. Moreover, they only work if infinite
universes are allowed, but interesting inexpressibility facts hold
also for finite models, for example, the fact that
<em>Q</em><sup><em>R</em></sup> and <em>Q</em><sub>even</sub> are not
definable in <em>FO</em>, or that <em>most</em> =
(<em>Q</em><sup><em>R</em></sup>)<sup>rel</sup> is not definable in
<em>FO</em>(<em>Q</em><sup><em>R</em></sup>). Logicians have developed much
more direct and efficient methods of showing undefinability results
that work also for finite
 models.<sup>[<a href="notes.html#13" name="note-13">13</a>]</sup></p>

<p>

The above properties in fact <em>characterize</em> <em>FO</em>, in the
sense that no proper extension of <em>FO</em> can have (certain
combinations of) them. This is the content of a celebrated theorem
about model-theoretic logics, Lindstr&ouml;m's Theorem, a version of
which is given below. For an accessible proof see, for example,
Ebbinghaus, Flum, and Thomas (1994).  We say that a logic <em>L</em> =
<em>FO</em>(<em>Q</em><sub>1</sub>,&hellip;,<em>Q</em><sub><em>n</em></sub>)
<em>relativizes</em> if the &lsquo;converse&rsquo; of (19) holds for
each <em>Q</em><sub><em>i</em></sub>, i.e., if each
(<em>Q</em><sub><em>i</em></sub>)<sup>rel</sup> is definable in
<em>L</em>.</p>

<blockquote>

<strong>THEOREM</strong> (Lindstr&ouml;m)
<br />
If <em>L</em> is compact and has the L&ouml;wenheim property, then
<em>L</em> &equiv; <em>FO</em>. Also, provided <em>L</em> relativizes,
if <em>L</em> is complete and has the L&ouml;wenheim property, or if
<em>L</em> has both the L&ouml;wenheim and the Tarski properties, then
<em>L</em> &equiv; <em>FO</em>.

</blockquote>

<h2><a name="comp">9. Generalized quantifiers and computation</a></h2>

<p>

In addition to the truth conditions associated with generalized
quantifiers, one may study the computations required to establish the
truth of a quantified statement in a model. Indeed, generalized
quantifiers turn up in various places in the part of computer science
that studies <em>computational complexity</em>. We sketch two
examples.</p>

<p>

Restrict attention to <em>finite</em> universes, assume
 <font size="-1">ISOM</font>
 throughout, and consider first type &lt;1&gt; quantifiers, or type
&lt;1,1&gt; quantifiers that are relativizations
 (<a href="#rela">Section 7</a>) 
 of these; we'll see in
 <a href="#exte">Section 12</a>
 that these types are highly relevant in natural language
contexts. Such quantifiers can be seen as binary relations between
natural numbers: using the same symbol we have
<em>Q</em><sub><em>M</em></sub>(<em>A</em>) &hArr; <em>Q</em>(|<em>M</em> -
<em>A</em>|,
 |<em>A</em>|).<sup>[<a href="notes.html#14" name="note-14">14</a>]</sup>
 These relations can in turn be coded as sets of <em>words</em>, for
example by letting a binary word
<em>w</em><sub>1</sub><sup>&hellip;</sup> <em>w</em><sub>m</sub>
correspond to a model (<em>M</em>, <em>A</em>) where |<em>M</em>| =
<em>m</em>, <em>A</em> &sube; <em>M</em>, and a 1 means
&lsquo;belonging to <em>A</em>&rsquo;, and 0 means
&lsquo;not belonging to <em>A</em>&rsquo;.  Thus |<em>A</em>| is the number of 1's; note that by
 <font size="-1">ISOM</font>,
 the order in the string doesn't matter. So <em>Q</em> is coded as a
set <em>W</em><sub>Q</sub> of such words (one for each <em>m</em>
 &ge;
 1).<sup>[<a href="notes.html#15" name="note-15">15</a>]</sup> One
 may then ask what it takes to
recognize that a word belongs to <em>W</em><sub>Q</sub>. The abstract
notion of an <em>automaton</em> can be used to give one kind of answer; automata
are machines that accept or reject words, and they are classified
according to the complexity of the operations they
 perform.<sup>[<a href="notes.html#16" name="note-16">16</a>]</sup></p>

<p>

A <em>finite</em> automaton has a finite number of <em>states</em>
including one start state and at least one accepting state. It starts
scanning a word at the leftmost symbol in the start state, and at each
step it moves one symbol to the right and enters a (possibly) new
state, according to a given <em>transition function</em>. If it can
move along the whole word ending in an accepting state, the word is
<em>accepted</em>. It accepts a set <em>W</em> of words if it accepts
all the words in <em>W</em> but no others from the same alphabet. It
is easy to construct a finite automaton accepting &forall; (or
&forall;<sup>rel</sup> = <em>all</em>), i.e., checking that <em>w</em>
consists only of 1's: just remain in the start state = accepting state
as long as 1's are encountered, but go to a rejecting state as soon as
a 0 is scanned, and remain there whatever is encountered afterwards. A
slightly more complex automaton accepts <em>Q</em><sub>even</sub>:
again there are two states, a start state = the accepting state and a
rejecting state, and this time remain in the <em>same</em> state when 0's are
scanned, but go to the <em>other</em> state when a 1 is scanned. To
end in the accepting state it is then necessary and sufficient that
there be an even number of 1's. This machine essentially uses
<em>cycles</em> of length 2, whereas the first example had only
1-cycles. Call an automaton of the latter kind <em>acyclic</em>. Van
Benthem showed that the <em>FO</em>-definable quantifiers are exactly
the ones accepted by finite automata that are acyclic and permutation
 closed.<sup>[<a href="notes.html#17" name="note-17">17</a>]</sup></p>

<p>

A slightly more complex automaton, the <em>pushdown</em> automaton,
has rudimentary memory resources in the form a of stack of symbols
that can be pushed or popped from the top, enabling it to keep track
to some extent of what went on at earlier steps. Another result by van
Benthem is that the type &lt;1&gt; quantifiers accepted by
pushdown automata are precisely those for which the corresponding
binary relation between numbers is definable (with first-order means)
in <em>additive arithmetic</em>, i.e., in the model (<em>N</em>, +),
where <em>N</em> = {0, 1, 2,&hellip;}. An example is
<em>Q</em><sup><em>R</em></sup> (or its relativization <em>most</em>):
we have <em>Q</em><sup><em>R</em></sup>(<em>m</em>, <em>n</em>) &hArr;
<em>m</em> &lt; <em>n</em>, and the right hand side is definable in
(<em>N</em>, +) by &exist;<em>x</em>(<em>x</em> &ne; 0 &and;
<em>m</em> + <em>x</em> = 
 <em>n</em>).<sup>[<a href="notes.html#18" name="note-18">18</a>]</sup></p>

<p>

Thus, an algorithmic characterization is matched with a logical one.
This has been one prominent direction in the study of algorithmic
complexity. Consider now the most general abstract automaton or
computational device, i.e., Turing machines. One (of many) interesting
complexity classes is PTIME: A set <em>W</em> of words is PTIME if
there is a polynomial <em>p</em>(<em>x</em>) (with natural number
coefficients) and a Turing machine accepting <em>W</em> such that
whenever <em>w</em> &isin; <em>W</em> has length <em>n</em>, the
accepting computation takes at most <em>p</em>(<em>n</em>) steps. PTIME
computations are &lsquo;feasible&rsquo;, in contrast with EXPTIME ones, where the
number of steps required may grow exponentially. An early result by
Immerman and Vardi is that the PTIME sets of (words coding) finite
models are precisely those describable by single sentences in
<em>FO</em>(<em>LFP</em>), which is <em>FO</em> logic with an added
mechanism for forming <em>least
 fixed-points</em>.<sup>[<a href="notes.html#19" name="note-19">19</a>]</sup>
 However, now one needs to represent not just monadic models but
arbitrary ones. For example, a binary relation on the universe
{1,&hellip;,<em>m</em>} can be represented by a word
<em>w</em><sub>11</sub> <sup>&hellip;</sup>
<em>w</em><sub>1<em>m</em></sub>#&hellip;#<em>w</em><sub><em>m</em>1</sub>
<sup>&hellip;</sup> <em>w</em><sub><em>m<em></em>m</em></sub>, where the relation holds
of (<em>i</em>, <em>j</em>) iff <em>w</em><sub><em>i</em><em>j</em></sub> = 1. But this
time the order does seem to matter, and in fact the Immerman and Vardi
result just mentioned only holds for models with a given linear order
and a binary predicate symbol standing for that order.</p>

<p>

Logics like <em>FO</em>(<em>LFP</em>) can be recast as logics of the
form <em>FO</em>(<em>Q</em><sub>1</sub>, <em>Q</em><sub>2</sub>,&hellip;).
Here infinitely many quantifiers may be required, but in some cases a
single one suffices. As to <em>FO</em>(<em>LFP</em>), it suffices to
add all the resumptions (see the end of 
 <a href="#arbi">Section 5</a>
 above) of a single quantifier. More
generally, let <em>FO</em><sup>*</sup>(<em>Q</em><sub>1</sub>,
<em>Q</em><sub>2</sub>,&hellip;) be like <em>FO</em>(<em>Q</em><sub>1</sub>,
<em>Q</em><sub>2</sub>,&hellip;) but with mechanisms for making
relativizations 
 (<a href="#rela">Section 7</a>)
 and for
resuming each <em>Q</em><sub><em>i</em></sub> to <em>k</em>-tuples for each
<em>k</em>. Then there is a single quantifier <em>Q</em> such that
<em>FO</em>(<em>LFP</em>) = <em>FO</em><sup>*</sup>(<em>Q</em>).</p>

<p>

So generalized quantifiers remain a simple and versatile way of adding
expressive power to <em>FO</em>. One natural question was if the
logical characterization of PTIME mentioned above could be improved
using generalized quantifiers, in particular if one could remove the
restriction to ordered structures in this way. The answer, however,
turned out to be negative, since Hella proved that the PTIME
computable properties of arbitrary finite structures cannot be
characterized by adding a finite number of generalized quantifiers to
<em>FO</em>, or even to <em>FO</em>(<em>LFP</em>). The question of
whether PTIME can be characterized by a logic of the form
<em>FO</em><sup>*</sup>(<em>Q</em>) remains open, however (indeed,
solving it would be a major breakthrough in complexity theory).</p>

<h2><a name="natu">10. Generalized quantifiers and natural language</a></h2>

<p>

Around 1980 a number of linguists began to realize that generalized
quantifiers of type &lt;1&gt; and &lt;1,1&gt; readily lend
themselves to the interpretation of <em>noun</em> phrases (NP), which are
ubiquitous syntactic units in many
 languages.<sup>[<a href="notes.html#20" name="note-20">20</a>]</sup> 
 This is immediately clear if one looks at the structure of a typical
English sentence whose subject is a quantified NP:</p>

<ol start="20">
<li><br />
<img alt="most students smoke" src="Fig2.jpg" width="199" height="155" />
</li>
</ol>

<p>

The (subject) NP consists of a determiner and a noun (N). Both the
noun and the verb phrase (VP) have sets as extensions, and so the
determiner is naturally taken to denote a binary relation between
sets, i.e., a type &lt;1,1&gt; quantifier. An utterance of (20)
has a (discourse) universe in the background (say, the set of people
at a particular university), but the meaning of 
 <font face="arial, helvetica" size="-1">most</font>, 
 <font face="arial, helvetica" size="-1">every</font>, 
 <font face="arial, helvetica" size="-1">at least five</font>
 and similar expressions is not tied to particular universes. For
example, the meaning of 
 <font face="arial, helvetica" size="-1">all</font> in</p>

<ol start="21">

<li><ol type="a">
<li>All cats like milk.</li>
<li>All electrons have negative charge.</li>
<li>All natural numbers have a successor.</li>
<li>All twins like each other.</li>
<li>All compact subsets of Hausdorff spaces are closed.</li>
</ol></li></ol>

has nothing to do with cats or electrons or numbers or twins or
Hausdorff spaces, nor with the discourse universes that may be
associated with the above examples. It simply stands for the inclusion
relation, regardless of what we happen to be talking about. Therefore,
the generalized quantifier <em>all</em>, which with each universe
<em>M</em> associates the inclusion relation over <em>M</em>, is
eminently suitable to interpret all, and similarly for other
determiners.

<p>

However, it is characteristic of sentences of the form (20) that the
noun argument and the VP argument are not on a par. The noun combines
with the determiner to form the NP, a separate constituent, and this
constituent can also be taken to signify a generalized quantifier,
this time of type &lt;1&gt; . Thus,
 <font face="arial, helvetica" size="-1">at least five students</font>
 denotes the set of subsets of
the universe which contain at least five students. This quantifier
results from <em>freezing</em> the first argument of the type
&lt;1,1&gt; <em>five</em> to the set of students; we write this
<em>five</em><sup><em>student</em></sup>.  In general, if <em>A</em>
is a fixed set and <em>Q</em> a type &lt;1,1&gt; quantifier, one
may define the type &lt;1&gt; quantifier
<em>Q</em><sup><em>A</em></sup> by</p>

<ol start="22">

<li>(<em>Q</em><sup>A</sup>)<sub><em>M</em></sub>(<em>B</em>)
&hArr;<sub>def</sub> <em>Q</em><sub><em>M</em> &cup;
<em>A</em></sub>(<em>A</em>, <em>B</em>) </li></ol>

<p>

for any <em>M</em> and any <em>B</em> &sube; <em>M</em>. In a
compositional semantics it is natural to take each constituent part of
a sentence to have a separate signification or meaning, and the
default significations of noun phrases are type &lt;1&gt;
quantifiers.</p>

<p>

This holds also for some NPs that lack determiners, such as proper
names. While
 <font face="arial, helvetica" size="-1">John</font>
 is assigned some individual <em>j</em> by an interpretation, the NP
 <font face="arial, helvetica" size="-1">John</font> can be taken to
denote the quantifier <em>I</em><sub><em>j</em></sub>, defined, for
any <em>M</em>, by</p>

<blockquote>(<em>I</em><sub><em>j</em></sub>)<sub><em>M</em></sub> =
{<em>B</em> &sube; <em>M</em> : <em>j</em> &isin;
<em>B</em>}</blockquote>

<p>

This is in fact motivated, not only because the interpretation of NPs
becomes more uniform, but also because
 <font face="arial, helvetica" size="-1">John</font>
 can combine with quantified NPs; cf.</p> 

<ol start="23">
<li>John and three professors came to the meeting.</li>
</ol>

<p>

Here it is convenient if
 <font face="arial, helvetica" size="-1">John</font>
 and
 <font face="arial, helvetica" size="-1">three professors</font>
 have the same semantic category. Note that generalized quantifiers
have a clear Boolean structure; define (here in the type &lt;1&gt;
case, but similarly for any other type)</p>

<blockquote>
(<em>Q</em><sub>1</sub> <img alt="and" src="wedge.jpg" />
<em>Q</em><sub>2</sub>)<sub><em>M</em></sub>(<em>A</em>) &hArr;
(<em>Q</em><sub>1</sub>)<sub><em>M</em></sub>(<em>A</em>) and
(<em>Q</em><sub>2</sub>)<sub><em>M</em></sub>(<em>A</em>)<br />
(&not;<em>Q</em>)<sub><em>M</em></sub>(<em>A</em>) &hArr; not
<em>Q</em><sub><em>M</em></sub>(<em>A</em>) </blockquote>

<p>

Then we can take the complex determiner in (23) to denote
<em>I</em><sub><em>j</em></sub> 
 <img alt="and" src="wedge.jpg" /> <em>three</em><sup><em>professor</em></sup>.
Similarly, the complex NP in</p>

<ol start="24">

<li>John and Mary came to the meeting.</li></ol>

<p>

signifies <em>I</em><sub><em>j</em></sub> 
 <img alt="and" src="wedge.jpg" />
 <em>I</em><sub><em>m</em></sub>.</p>

<p>

The first argument (coming from the noun) of a type &lt;1,1&gt;
determiner denotation is often called its <em>restriction</em>, and
the second its <em>scope</em>. The difference in syntactic status
between these two arguments turns out to have a clear semantic
counterpart.</p>

<h2><a name="cons">11. Conservativity</a></h2>

<p>

It was observed early on that type &lt;1, 1&gt; quantifiers
denoted by determiners in natural languages have the following
property:</p>

<ol start="25">
<li><em>Conservativity</em>
 (<font size="-1">CONSERV</font>):<br /> For all <em>M</em> and all
<em>A</em>, <em>B</em> &sube; <em>M</em>,
<em>Q</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr;
<em>Q</em><sub><em>M</em></sub>(<em>A</em>, <em>A</em> &cap;
<em>B</em>).  </li></ol>

<p>

This can be seen from sentence pairs such as the following, where it
is clear that the second sentence is just an awkward way of expressing
the first:</p>

<ol start="26">

<li><ol type="a">
<li>Most students smoke.</li>
<li>Most students are students who smoke.<br /><br /></li>
</ol></li>

<li><ol type="a">
<li>At least five professors were absent.</li>
<li>At least five professors were absent professors.<br /><br /></li>
</ol></li>

<li><ol type="a">
<li>More than one third of the graduate students are foreigners.</li>
<li>More than one third of the graduate students are foreign graduate
students.</li>
</ol></li>
</ol>

<p>

 <font size="-1">CONSERV</font>
 says that only the part of <em>B</em> which is common to <em>A</em>
matters for the truth of <em>Q</em><sub><em>M</em></sub>(<em>A</em>,
<em>B</em>). That is, the part <em>B</em> - <em>A</em> in Figure 1
doesn't matter. This appears to hold for all determiner denotations,
but it fails for perfectly natural logical quantifiers, such as
<em>MO</em> and <em>I</em> from the list (14) above. The reason is
that it is characteristic of determiner denotations that the
restriction argument <em>restricts the domain of quantification</em>
to that argument.</p>

<h2><a name="exte">12. Extension</a></h2>

<p>

Actually, the idea of domain restriction has one further ingredient.
To restrict the domain of quantification to a subset <em>A</em>
of <em>M</em> means not only that <em>B</em> - <em>A</em> is
irrelevant but the whole part of <em>M</em> that lies outside
<em>A</em>, and hence also the part <em>M</em> - (<em>A</em> &cup;
<em>B</em>) in Figure 1. This in turn is an instance of a more general
property, applicable to arbitrary generalized quantifiers:</p>

<ol start="29">

<li><em>Extension</em>
 (<font size="-1">EXT</font>):<br /> If <em>Q</em> is of type
&lt;<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt;,
<em>R</em><sub><em>i</em></sub> &sube;
<em>M</em><sup><em>n</em><sub><em>i</em></sub></sup> for 1 &le;
<em>i</em> &le; <em>k</em>, and <em>M</em> &sube; <em>M&prime;</em>,
then <br />
<em>Q</em><sub><em>M</em></sub>(<em>R</em><sub>1</sub>,&hellip;,
<em>R</em><sub><em>k</em></sub>) &hArr;
<em>Q</em><sub><em>M&prime;</em></sub>(<em>R</em><sub>1</sub>,&hellip;,
<em>R</em><sub><em>k</em></sub>).</li></ol>

<p>

That is, nothing happens when the universe is extended, or shrunk, as
long as the arguments are not changed. Now recall that for type
&lt;1&gt; quantifiers we already provided a logical mechanism for
restricting the quantification domain to a subuniverse, in terms of
relativization
 (<a href="#rela">Section 7</a>).
 We can now see (in (b) below) that the combination of
 <font size="-1">CONSERV</font>
 and
 <font size="-1">EXT</font>
 amounts to exactly the same thing:</p>

<blockquote>

<strong>FACT</strong>
 <ol type="a"> 
 <li>For any quantifier <em>Q</em>, <em>Q</em><sup>rel</sup> satisfies
 <font size="-1">EXT</font>.</li> <li>A type &lt;1, 1&gt; quantifier is
 <font size="-1">CONSERV</font> and
 <font size="-1">EXT</font>
 if and only if it is the relativization of a type &lt;1&gt;
 quantifier.<sup>[<a href="notes.html#21" name="note-21">21</a>]</sup>
 </li>
</ol>
</blockquote>

<p>

Again, all determiner denotations appear to satisfy
 <font size="-1">EXT</font>. At first sight, nothing in principle
would seem to prevent a language from containing a determiner, say
 <font face="arial, helvetica" size="-1">evso</font>, which meant
<em>every</em> on universes with less than 10 elements and
<em>some</em> on larger universes. But not only is there in fact no
such determiner in any language &mdash; there couldn't be, if the noun
(restriction) argument of a determiner is to restrict the domain of
quantification to the denotation of that noun.</p>

<p>

A quantifier such as
 <font face="arial, helvetica" size="-1">evso</font>
 is intuitively <em>not constant</em>, in the
sense that it doesn't mean the same, or is not interpreted by the same
rule, on every universe.
 <font size="-1">EXT</font> can be seen as a strong requirement of
constancy: the rule interpreting <em>Q</em> doesn't even mention the
universe. Indeed, many quantifiers from language and logic are
 <font size="-1">EXT</font>. As we saw, all relativized quantifiers
are
 <font size="-1">EXT</font>, and all the other quantifiers in the
lists (13) &ndash; (15) as well, except
 <em>W</em>.<sup>[<a href="notes.html#22" name="note-22">22</a>]</sup>
 In fact, it seems that all quantifiers taking more than one argument
that show up in natural language contexts are
 <font size="-1">EXT</font>. And many type &lt;1&gt; quantifiers are
 <font size="-1">EXT</font> too, for example, &exist;,
<em>I</em><sub><em>j</em></sub>, <em>Q</em><sup><em>A</em></sup> (see
(22) above), and all in the list (8)
 except <em>Q</em><sup><em>R</em></sup>.</p>

<p>

But &forall; and <em>Q</em><sup><em>R</em></sup> are not
 <font size="-1">EXT</font>. Yet one is inclined to say for them too
that they mean the same on every universe, so it seems that
 <font size="-1">EXT</font> 
 is a sufficient conditions for constancy, but not necessary. The case
of &forall; is particularly interesting since one might argue that it
interprets NPs like
 <font face="arial, helvetica" size="-1">everything</font>
 or
 <font face="arial, helvetica" size="-1">every thing</font>.
 The crux here is
 <font face="arial, helvetica" size="-1">thing</font>.
 If this expression is seen as a logical constant that always denotes
the universe, then these NPs do denote &forall;: for all <em>M</em>
and all <em>B</em> &sube; <em>M</em>,</p>

<blockquote>

(<em>every</em><sup><em>thing</em></sup>)<sub><em>M</em></sub>(<em>B</em>)
&hArr; <em>every</em><sub><em>M</em></sub>(<em>M</em>, B)
&hArr; M &sube; B &hArr; M = B &hArr;
&forall;<sub><em>M</em></sub>(<em>B</em>)</blockquote>

<p>

When
 <font size="-1">EXT</font>
 holds, we can usually drop the subscript <em>M</em> and write, for
example,</p>

<blockquote><em>Q</em>(<em>A</em>, <em>B</em>)</blockquote>

rather than <em>Q</em><sub><em>M</em></sub>(<em>A</em>,
<em>B</em>). That is, a suitable universe can be presupposed but left
in the background. We often follow this convention below when dealing
with
 <font size="-1">EXT</font> quantifiers.

<h2><a name="dete">13. Determiners that are not ISOM</a></h2>

<p>

Consider</p>

<ol start="30">

<li>John's books were stolen.</li>
<li>Some student's books have not been returned.</li>
<li>No professor except Mary came to the meeting.</li>
<li>All beach goers except a few enthusiastic swimmers were fully clothed.</li>
<li>More male than female students smoke.</li></ol>

<p>

The expressions
 <font face="arial, helvetica" size="-1">John's</font>,
 <font face="arial, helvetica" size="-1">some student's</font>,
 <font face="arial, helvetica" size="-1">no _ except Mary</font>,
 <font face="arial, helvetica" size="-1">all _ except a few enthusiastic swimmers</font>,
 <font face="arial, helvetica" size="-1">more male than female</font>
 are quite naturally seen as determiners: when combined with nouns
they form phrases that behave like ordinary NPs. Also, the type
&lt;1,1&gt; quantifiers they signify are
 <font size="-1">CONSERV</font> and
 <font size="-1">EXT</font>. For example, the sentences in the
following pair are trivially equivalent:</p>

<ol start="35">

<li><ol type="a">
 <li>John's books were stolen.</li>
 <li>John's books are books that were stolen.</li>
 </ol>
 </li>
</ol>

But in contrast with the previous examples, they are not
 <font size="-1">ISOM</font>,
 since they involve some fixed individual or property: if John's books
were stolen, and the number of stolen books is the same as the number
of red pencils (in some discourse universe), and the number of books
that weren't stolen is the same as the number of pencils that aren't
red, it does not follow that John's pencils are red, as
 <font size="-1">ISOM</font> would have it.

<p>

However, just as the
 non-<font size="-1">ISOM</font> quantifier
<em>three</em><sup><em>student</em></sup> results by freezing the
restriction argument of the
 <font size="-1">EXT</font>
 quantifier <em>three</em>, the
 non-<font size="-1">ISOM</font>
quantifiers above result by freezing arguments in more abstract
relations, which <em>are</em>
 <font size="-1">ISOM</font>. We illustrate this with the possessive
determiner
 <font face="arial, helvetica" size="-1">John's</font>.<sup>[<a href="notes.html#23" name="note-23">23</a>]</sup></p>

<p>

Given that
 <font face="arial, helvetica" size="-1">John</font> denotes
an individual <em>j</em>, the determiner
 <font face="arial, helvetica" size="-1">John's</font>
 can be defined, for all <em>M</em> and all <em>A</em>, <em>B</em>
&sube; <em>M</em>,
 by<sup>[<a href="notes.html#24" name="note-24">24</a>]</sup></p>

<ol start="36">

<li><font face="arial, helvetica" size="-1">John's</font><sub><em>M</em></sub>(<em>A</em>,
 <em>B</em>) &hArr; &empty; &ne; {<em>x</em> &isin; <em>A</em> :
<em>R</em><sub>0</sub>(<em>j</em>, <em>x</em>)} &sube; <em>B</em></li>
</ol>

<p>

Here <em>R</em><sub>0</sub> is some &lsquo;possessor&rsquo; relation;
it is well-known that this relation varies a lot with the
circumstances &mdash; one could be talking about the books that John
owns, or has written, or borrowed, or bought as a present to Mary,
etc. Suppose <em>R</em><sub>0</sub> is ownership. Then (30) says that
John owns at least one book, and that all of the books he owns were
stolen. Now consider the more general &lsquo;quantifier&rsquo;
defined, for <em>a</em> &isin; <em>M</em>, <em>R</em> &sube;
<em>M</em><sup>2</sup>, and <em>A</em>, <em>B</em> &sube; <em>M</em>,
by</p>

<blockquote>

<strong>P</strong><sub><em>M</em></sub>(<em>a</em>, <em>R</em>, <em>A</em>,
<em>B</em>) &hArr; &empty; &ne; {<em>x</em> &isin; <em>A</em> :
<em>R</em>(<em>a</em>, <em>x</em>)} &sube; <em>B</em></blockquote>

<p>

We could say that this is a generalized quantifier of type
&lt;0,2,1,1&gt;, letting 0 stand for individuals. <strong>P</strong>
is
 <font size="-1">ISOM</font> (extending definition (16) in the obvious
way to quantifiers of this type), and
 <font face="arial, helvetica" size="-1">John's</font>
 results by freezing the first two arguments to suitable values.</p>

<p>

Similar constructions work for other cases of quantifier expressions
in natural languages that denote
 non-<font size="-1">ISOM</font>
quantifiers. For example, the determiner
 <font face="arial, helvetica" size="-1">no _ except Mary</font>
 denotes (given that
 <font face="arial, helvetica" size="-1">Mary</font>
 refers to <em>m</em>)</p>

<blockquote>

(<em>no _ except
Mary</em>)<sub><em>M</em></sub>(<em>A</em>, <em>B</em>) &hArr;
<em>A</em> &cap; <em>B</em> = {<em>m</em>}</blockquote>

<p>

That is, (32) says that Mary is a professor, that she came to the
meeting, and that no other professor did. Again, a corresponding
 <font size="-1">ISOM</font>
 quantifier of type &lt;0,1,1&gt; is
readily defined. In conclusion,
 <font size="-1">ISOM</font> remains a fundamental property in the
semantics of quantifier expressions, and not only in logical
languages.</p>

<p>

<em>Digression</em>:
 <font size="-1">ISOM</font>, i.e., topic-neutrality, is standardly
seen as a mark of
 <em>logicality</em>.<sup>[<a href="notes.html#25" name="note-25">25</a>]</sup>
 It is possible to distinguish this property from <em>constancy</em>,
in the earlier mentioned sense of meaning the same over different
universes. One might therefore consider
 <font size="-1">ISOM</font> +
 <font size="-1">EXT</font> as an attempt to capture the idea of a
<em>logical constant</em>. This doesn't quite work since
 <font size="-1">ISOM</font> appears to be a necessary (but perhaps not
sufficient) condition for logicality, and
 <font size="-1">EXT</font> a sufficient (but not necessary) condition
of constancy. As noted, &forall; is not
 <font size="-1">EXT</font> 
(but perhaps one could live with that, since &exist; (and negation) is
 <font size="-1">EXT</font> so the usual logical constants are at least
definable from
 <font size="-1">ISOM</font> +
 <font size="-1">EXT</font> ones). In any case, this combination of
properties has an even more succinct formulation, which is just like
 <font size="-1">ISOM</font> except that one allows arbitrary
<em>injections</em> of the universe. Suppose <em>Q</em> is of type
&lt;<em>n</em><sub>1</sub>,&hellip;,<em>n</em><sub><em>k</em></sub>&gt;
:</p>

<ol start="37">

<li><em>Injection</em>
 (<font size="-1">INJ</font>): <br /> If
<em>R</em><sub><em>i</em></sub> &sube;
<em>M</em><sup><em>n</em><sub><em>i</em></sub></sup> for 1 &le;
<em>i</em> &le; <em>k</em>, and <em>f</em> is an injection (a one-one
function) from <em>M</em> into <em>M&prime;</em>, then
<em>Q</em><sub><em>M</em></sub>(<em>R</em><sub>1</sub>,&hellip;,<em>R</em><sub><em>k</em></sub>)
&hArr;
<em>Q</em><sub><em>M&prime;</em></sub>(<em>f</em>(<em>R</em><sub>1</sub>),&hellip;,<em>f</em>(<em>R</em><sub><em>k</em></sub>))
</li></ol>

<p>

(where <em>f</em> (<em>R</em><sub><em>i</em></sub>) =
{(<em>f</em>(<em>a</em><sub>1</sub>),&hellip;,
<em>f</em>(<em>a</em><sub><em>n</em><sub><em>i</em></sub></sub>)) :
(<em>a</em><sub>1</sub>,&hellip;,<em>a</em><sub><em>n</em><sub><em>i</em></sub></sub>)
&isin; <em>R</em><sub><em>i</em></sub>}). Then it is easy to verify
the following</p>

<blockquote>

<strong>FACT</strong><br />
 <font size="-1">ISOM</font> +
 <font size="-1">EXT</font> =
 <font size="-1">INJ</font>
</blockquote>

<p>

There has been some discussion about whether quantifiers like
<em>most</em> or <em>two-thirds of the</em> are logical constants. It
is not clear that this is a well-defined question since the notion of
a logical constant is notoriously hard to pin-point. But that these
quantifiers satisfy
 <font size="-1">INJ</font>
 is certain. <em>End of digression</em>.</p>

<h2><a name="othe">14. Other quantifier expressions in natural language</a></h2>

<p>

Generalized quantifiers of other types than &lt;1&gt; and
&lt;1,1&gt; have also been used to account for natural language
quantification. Without going into detail about the often complex
issues of interpretation arising here, we illustrate with a few
examples.<sup>[<a href="notes.html#26" name="note-26">26</a>]</sup></p>

<ol start="38">

<li>More women than men smoke.</li></ol>

<p>

If
 <font face="arial, helvetica" size="-1">more women than men</font>
is an NP, which seems to be the case, then the determiner
 <font face="arial, helvetica" size="-1">more _ than</font> takes
<em>two</em> restriction arguments and one scope argument, and thus
denotes the type &lt;1,1,1&gt; generalized quantifier</p>

<blockquote>

<em>more _ than</em>(<em>A</em>, <em>B</em>, <em>C</em>) &hArr;
|<em>A</em> &cap; <em>C</em>| &gt; |<em>B</em> &cap; <em>C</em>|
</blockquote>

<p>

Keenan and Moss (1984) provide a thorough account of similar
constructions requiring monadic quantifiers with more than two
 arguments.<sup>[<a href="notes.html#27" name="note-27">27</a>]</sup>
 <em>More _ than</em> is
 <font size="-1">ISOM</font> and
 <font size="-1">EXT</font>. It is also
conservative in an extended sense, for type &lt;1,1,1&gt;
quantifiers <em>Q</em> where the first two arguments are
restrictions:</p>

<ol start="39">

<li><em>Q</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>, <em>C</em>) &hArr;
<em>Q</em><sub><em>M</em></sub>(<em>A</em>, <em>B</em>, (<em>A</em> &cup;
<em>B</em>) &cap; <em>C</em>)</li></ol>

<p>
Next, consider</p>

<ol start="40">

<li>
<ol type="a">
<li>People usually are grateful to firemen who rescue them.</li>
<li>Men seldom make passes at girls who wear glasses. (Dorothy
Parker)</li>
</ol></li></ol>

<p>

Adverbs like
 <font face="arial, helvetica" size="-1">usually</font>,
 <font face="arial, helvetica" size="-1">seldom</font>,
 <font face="arial, helvetica" size="-1">always</font>,
 <font face="arial, helvetica" size="-1">never</font>
 can be taken to denote generalized
 quantifiers.<sup>[<a href="notes.html#28" name="note-28">28</a>]</sup>
 For example, <font face="arial, helvetica" size="-1">Dogs never
meow</font> is roughly synonymous with
 <font face="arial, helvetica" size="-1">No dogs meow</font>. But for
(40), it can be argued that there is a reading where the quantifier
applies to <em>pairs</em>: among the pairs consisting of a person and
a fireman who rescues that person, a majority are such that the person
is grateful. This is just the <em>resumption</em> of <em>most</em> to
pairs, that we defined in (15):</p>

<blockquote><em>Res</em><sup>2</sup>(<em>most</em>)(<em>R</em>, <em>S</em>)
&hArr; |<em>R</em> &cap; <em>S</em>| &gt; |<em>R</em> &minus;
<em>S</em>|</blockquote>

<p>

So in (40a), <em>R</em>(<em>a</em>, <em>b</em>) iff <em>a</em> &isin;
<em>person</em> and <em>b</em> &isin; <em>fireman</em> and <em>a</em>
<em>rescued</em> <em>b</em>, and <em>S</em>(<em>a</em>, <em>b</em>) iff
<em>a</em> is grateful to <em>b</em>. It can be shown that for many
quantifiers, in particular <em>most</em>, <em>Res</em><sup><em>n</em></sup>(<em>Q</em>)
is not definable in <em>FO</em>(<em>Q</em>). In fact,
<em>Res</em><sup>2</sup>(<em>most</em>) is not definable from any
finite number of monadic quantifiers, so it is an example of an
irreducibly polyadic
 quantifier.<sup>[<a href="notes.html#29" name="note-29">29</a>]</sup></p>

<p>

On the other hand, sentences with nested ordinary NPs, such as</p>

<ol start="41">
<li>Most films were reviewed by two critics.</li></ol>

<p>

can also be construed with a polyadic quantifier <em>Q</em>, this time
of type &lt;1,1,2&gt;, whose truth conditions may be given by
the following logical sentence,</p>

<blockquote><em>Qx</em>, <em>y</em>,
<em>z</em><em>u</em>(<em>A</em>(<em>x</em>), <em>B</em>(<em>y</em>),
<em>R</em>(<em>z</em>, <em>x</em>)) &harr; <em>most</em>
x(<em>A</em>(<em>x</em>), <em>two</em> <em>y</em>(<em>B</em>(<em>y</em>),
<em>R</em>(<em>x</em>, <em>y</em>)))</blockquote>

<p>

but as this sentence shows, <em>Q</em> is definable from <em>most</em>
and
 <em>two</em>.<sup>[<a href="notes.html#30" name="note-30">30</a>]</sup></p>

<p>

Next:</p>

<ol start="42">
<li>Five Boston pitchers sat alongside each other.</li></ol>

<p>

This can have the truth conditions</p>

<blockquote>&exist; <em>X</em> &sube; <em>Boston pitcher</em>[|<em>X</em>| = 5
&amp; <em>RECIP</em>(<em>X</em>, <em>sat alongside</em>)]</blockquote>

<p>

where <em>RECIP</em> is the type &lt;1,2&gt; quantifier defined
in (15). That is, there is a set of five Boston pitchers such that if
you take any two of those, either they sit next to each other, or
there is one pitcher, or two, or at most three (all in the chosen
set), between them. This is just one of several polyadic quantifiers
that occur in reciprocal
 sentences.<sup>[<a href="notes.html#31" name="note-31">31</a>]</sup></p>

<p>

Finally, consider the sentence</p>

<ol start="43">
<li>Most boys in your class and most girls in my class have all dated each
 other.</li></ol>

<p>

 This has been put forward as an example of <em>branching quantification</em>,
which can be written in a two-dimensional logical format as</p>

<ol start="44">
<li><br />
<table>
<tr>
<td><em>most</em> <em>x</em> <em>A</em>(<em>x</em>)<br /><br />
<em>most</em> <em>y</em> <em>B</em>(<em>y</em>)</td>
<td><font size="+4">&gt;</font></td>
<td><em>R</em>(<em>x</em>,<em>y</em>)</td>
</tr>
</table>
</li></ol>

<p>

where the intended reading is that there is a subset <em>X</em> of
<em>A</em> containing most of the elements of <em>A</em>, and a
similarly large subset <em>Y</em> of <em>B</em>, such that each pair
(<em>a</em>, <em>b</em>) where <em>a</em> &isin; <em>X</em> and
<em>b</em> &isin; <em>Y</em> belongs to the relation <em>R</em>. More
generally, we have a polyadic quantifier of type &lt;1,1,2&gt;
defined for any <em>Q</em><sub>1</sub>, <em>Q</em><sub>2</sub> of type
&lt;1,1&gt; by</p>

<ol start="45">
<li>
<em>Br</em>(<em>Q</em><sub>1</sub>, <em>Q</em><sub>2</sub>)(<em>A</em>,
<em>B</em>, <em>R</em>) &hArr;
&exist; <em>X</em> &sube; <em>A</em> &exist; <em>Y</em> &sube;
<em>B</em> [<em>Q</em><sub>1</sub>(<em>A</em>, <em>X</em>) &amp;
<em>Q</em><sub>2</sub>(<em>B</em>, <em>Y</em>) &amp;
<em>X</em>&times;<em>Y</em> &sube; 
 <em>R</em>]<sup>[<a href="notes.html#32" name="note-32">32</a>]</sup>
</li></ol>

<p>

Quite plausibly, this gives a reading of (43).  Note that <em>x</em>
and <em>y</em> here are <em>independent</em> of each other.  If one
instead would use any one of the linear sentences</p>

<blockquote>

<em>most</em> <em>x</em>(<em>A</em>(<em>x</em>), <em>most</em>
<em>y</em>(<em>B</em>(<em>y</em>), <em>R</em>(<em>x</em>,
<em>y</em>))) <br />
<em>most</em> <em>y</em>(<em>B</em>(<em>y</em>), <em>most</em>
<em>x</em>(<em>A</em>(<em>x</em>), <em>R</em>(<em>x</em>,
<em>y</em>)))</blockquote>

<p>

either <em>y</em> depends on <em>x</em> or <em>vice versa</em>. For
example, it is not hard to see that the first of these sentences has
the truth condition</p>

<blockquote>

&exist;<em>X</em> &sube; <em>A</em> [<em>most</em>(<em>A</em>,
<em>X</em>) &amp; &forall;<em>a</em> &isin; <em>X</em>
&exist;<em>Y</em> &sube; <em>B</em> [<em>most</em>(<em>B</em>,
<em>Y</em>) &amp; <em>Y</em> &sube; {<em>b</em> :
<em>R</em>(<em>a</em>, <em>b</em>)}]]</blockquote>

<p>

which clearly shows that the sets <em>Y</em> depend on <em>X</em>, in
contrast with the situation in (45).  The point of the two-dimensional
partially ordered structure in (44) is that this semantic independence
is also reflected in the
 syntax.<sup>[<a href="notes.html#33" name="note-33">33</a>]</sup></p>

<p>

It can be shown that <em>Br</em>(<em>most</em>, <em>most</em>) is not
expressible in <em>FO</em>(<em>most</em>) alone; indeed not with any
finite number of monadic
 quantifiers.<sup>[<a href="notes.html#34" name="note-34">34</a>]</sup></p>

<p>

Many other constructions in natural languages can be taken to
involve generalized quantifiers, but the above sentences at least
indicate some of the relevant examples.</p>

<h2><a name="Bib">Bibliography</a></h2>

<ul>

<li>Barwise, J. 1978, &ldquo;On branching
quantifiers in English,&rdquo; <em>J. Phil. Logic</em> 8, 47-80.</li>

<li>Barwise, J. and Cooper, R., 1981, &ldquo;Generalized quantifiers
and natural language,&rdquo; <em>Linguistics and Philosophy 4</em>,
159-219.</li>

<li>Barwise, J. and Feferman, S. (eds.), 1985, <em>Model-Theoretic
Logics</em>, Springer-Verlag, Berlin.</li>

<li>Dalrymple, M., Kanazawa, M., Kim, Y., Mchombo, S., and Peters,
S., 1998, &ldquo;Reciprocal expressions and the concept of
reciprocity,&rdquo; <em>Linguistics and Philosophy</em> 21,
159-210.</li>

<li>Ebbinghaus, H.D. and Flum, J, 1995,
<em>Finite Model Theory</em>, Springer, Berlin.</li>

<li>Ebbinghaus, H.D., Flum, J., and Thomas, W., 1994,
<em>Mathematical Logic</em>, Springer, Berlin.</li>

<li>Hella, L., V&auml;&auml;n&auml;nen, J., and Westerst&aring;hl,
D., 1997, &ldquo;Definability of polyadic lifts of generalized
quantifiers,&rdquo; <em>Journal of Logic, Language and
Information</em> 6, 305-335.</li>

<li>Henkin, L., 1961, &ldquo;Some remarks on infinitely long
formulas,&rdquo; in <em>Infinitistic Methods</em>, Pergamon Press,
Oxford, 167-183.</li>

<li>Higginbotham, J. and May, R., 1981, &ldquo;Questions, quantifiers and
crossing,&rdquo; <em>Linguistic Review</em> 1, 41-79.</li>

<li>Hintikka, J., 1973, &ldquo;Quantifiers vs. quantification
theory,&rdquo; <em>Dialectica</em> 27, 329-358.</li>

<li>Hopcroft, J.E. and Ullman, J.D., 1979, <em>Introduction to
Automata Theory, Languages, and Computation</em>, Addison-Wesley,
London..</li>

<li>Keenan, E. and Moss, L., 1984, &ldquo;Generalized quantifiers and
the expressive power of natural language,&rdquo; in J. van Benthem and
A. ter Meulen (eds.), <em>Generalized quantifiers in Natural
Language</em>, Foris, Dordrecht, 73-124.</li>

<li>Keenan, E. and Stavi, J., 1986, &ldquo;A semantic
characterization of natural language determiners,&rdquo;
<em>Linguistics and Philosophy</em> 9, 253-326.</li>

<li>Keenan, E. and Westerst&aring;hl, D., 1997, &ldquo;Generalized
quantifiers in linguistics and logic,&rdquo; in J. van Benthem and
A. ter Meulen (eds.), <em>Handbook of Logic and Language</em>,
Elsevier, Amsterdam, 837-893.</li>

<li>Lewis, D., 1975, &ldquo;Adverbs of quantification,&rdquo; in
E. Keenan (ed.), <em>Formal Semantics of Natural Language</em>,
Cambridge UP, Cambridge, MA, 3-15.</li>

<li>Lindstr&ouml;m, P., 1966, &ldquo;First-order predicate logic with
generalized quantifiers,&rdquo; <em>Theoria</em> 32,
186-195.</li>

<li>Luosto, K., 2000, &ldquo;Hierarchies of monadic generalized
quantifiers,&rdquo; <em>Journal of Symbolic Logic</em> 65,
1241-1263.</li>

<li>Montague, R., 1974, <em>Formal Philosophy</em> (edited and with an
introduction by R. Thomason), Yale UP, New Haven.</li>

<li>Mostowski, A., 1957, &ldquo;On a generalization of
quantifiers,&rdquo; <em>Fund. Math.</em> 44, 12-36.</li>

<li>Mostowski, M., 1998, &ldquo;Computational semantics for monadic
quantifiers,&rdquo; <em>Journal of Applied Non-Classical Logics</em>
8, 107-121.</li>

<li>Parsons, T., 2004, 
 &ldquo;<a href="../../archives/sum2004/entries/square/">The traditional square of opposition</a>,&rdquo; in E. N. Zalta (ed.) <em>The Stanford Encyclopedia
of Philosophy</em> (Summer 2004 Edition), URL =
&lt;http://plato.stanford.edu/archives/sum2004/entries/square/&gt;</li>

<li>Peters, S. and Westerst&aring;hl, D. 2002, &ldquo;Does English
really have resumptive quantification?&rdquo; in D. Beaver et
al. (eds.), <em>The Construction of Meaning</em>, CSLI Publications,
Stanford, 181-195.</li>

<li>--------, 2005, <em>Quantifiers in Language and Logic</em>,
Oxford University Press, Oxford, to appear.</li>

<li>Sher, G. 1997, &ldquo;Partially-ordered (branching) generalized
quantifiers: a general definition,&rdquo; <em>Journal
of Philosophical Logic</em> 26, 1-43.</li>

<li>van Benthem, J., 1986, <em>Essays in Logical Semantics</em>,
D. Reidel, Dordrecht.</li>

<li>--------, 1987, &ldquo;Towards a computational semantics,&rdquo;
in P. G&auml;rdenfors (ed.), <em>Generalized Quantifiers</em>,
D. Reidel, Dordrecht, 31-71.</li>

<li>--------, 2002, &ldquo;Invariance and Definability: two faces of
logical constants,&rdquo; in W. Sieg, R. Sommer, and C. Talcott (eds),
<em>Reflections of the Foundations of Mathematics.  Essays in Honor of
Sol Feferman, ASL Lecture Notes in Logic</em> 15, 426-446.</li>

<li>Westerst&aring;hl, D. 1987, &ldquo;Branching generalized
quantifiers and natural language,&rdquo; in P. G&auml;rdenfors (ed.),
<em>Generalized Quantifiers</em>, D.  Reidel, Dordrecht,
269-298.</li>

<li>--------, 1989, &ldquo;Quantifiers in formal and natural
languages,&rdquo; in D. Gabbay and F.  Guenthner (eds), <em>Handbook
of Philosophical Logic</em>, vol. IV, D. Reidel, 1-131.</li>

<li>Williamson, T., 2003, &ldquo;Everything,&rdquo; <em>Philosophical
Perspectives</em> 17, 415-465.</li> </ul>

<h2><a name="Oth">Other Internet Resources</a></h2>

<p>
[Please contact the author with suggestions.]</p>

<h2><a name="Rel">Related Entries</a></h2>

 <a href="../aristotle-logic/">Aristotle, General Topics: logic</a> |
 <a href="../frege/">Frege, Gottlob</a> |
 <a href="../logic-classical/">logic: classical</a> |
 <a href="../model-theory/">model theory</a> |
 <a href="../square/">square of opposition</a>

<!--DO NOT MODIFY THIS LINE AND BELOW-->
<p></p>

<div class="center">
 <a href="../../info.html#c">Copyright &copy; 2005</a>
</div>

<table border="0" cellpadding="4" class="center">
<tr>
<td align="center" valign="top"><a href="http://plato.stanford.edu/subject-editors/westerstahl.html" target="other"><strong>Dag Westerst&aring;hl</strong></a> <br />
 <a href="m&#97;ilto:Dag&#37;2eWesterstahl&#37;40phil&#37;2egu&#37;2ese"><em>Dag<abbr title=" dot ">&#46;</abbr>Westerstahl<abbr title=" at ">&#64;</abbr>phil<abbr title=" dot ">&#46;</abbr>gu<abbr title=" dot ">&#46;</abbr>se</em></a></td>
</tr>
</table>

<hr />

<p class="center">
 <a href="../../contents.html#a" class="plain">A</a> |
 <a href="../../contents.html#b" class="plain">B</a> |
 <a href="../../contents.html#c" class="plain">C</a> |
 <a href="../../contents.html#d" class="plain">D</a> |
 <a href="../../contents.html#e" class="plain">E</a> |
 <a href="../../contents.html#f" class="plain">F</a> |
 <a href="../../contents.html#g" class="plain">G</a> |
 <a href="../../contents.html#h" class="plain">H</a> |
 <a href="../../contents.html#i" class="plain">I</a> |
 <a href="../../contents.html#j" class="plain">J</a> |
 <a href="../../contents.html#k" class="plain">K</a> |
 <a href="../../contents.html#l" class="plain">L</a> |
 <a href="../../contents.html#m" class="plain">M</a> |
 <a href="../../contents.html#n" class="plain">N</a> |
 <a href="../../contents.html#o" class="plain">O</a> |
 <a href="../../contents.html#p" class="plain">P</a> |
 <a href="../../contents.html#q" class="plain">Q</a> |
 <a href="../../contents.html#r" class="plain">R</a> |
 <a href="../../contents.html#s" class="plain">S</a> |
 <a href="../../contents.html#t" class="plain">T</a> |
 <a href="../../contents.html#u" class="plain">U</a> |
 <a href="../../contents.html#v" class="plain">V</a> |
 <a href="../../contents.html#w" class="plain">W</a> |
 <a href="../../contents.html#x" class="plain">X</a> |
 <a href="../../contents.html#y" class="plain">Y</a> |
 <a href="../../contents.html#z" class="plain">Z</a>
</p>

<h4 class="center">Stanford Encyclopedia of Philosophy</h4>

<p></p>

</body>
</html>
