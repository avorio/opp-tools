/*
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; version 2 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Michele Baldessari <michele@pupazzo.org> 2006
*/

function ddump(text)
{
  dump(text + "\n");
}

function ddumpObject(obj, name, maxDepth, curDepth)
{
  if (curDepth == undefined)
    curDepth = 0;
  if (maxDepth != undefined && curDepth > maxDepth)
    return;

  var i = 0;
  for (prop in obj)
  {
    i++;
    if (typeof(obj[prop]) == "object")
    {
      if (obj[prop] && obj[prop].length != undefined)
        ddump(name + "." + prop + "=[probably array, length "
              + obj[prop].length + "]");
      else
        ddump(name + "." + prop + "=[" + typeof(obj[prop]) + "]");
      ddumpObject(obj[prop], name + "." + prop, maxDepth, curDepth+1);
    }
    else if (typeof(obj[prop]) == "function")
      ddump(name + "." + prop + "=[function]");
    else
      ddump(name + "." + prop + "=" + obj[prop]);
  }
  if (!i)
    ddump(name + " is empty");    
}

function WebProgressListener() {
}

WebProgressListener.prototype = {
  _requestsStarted: 0,
  _requestsFinished: 0,

  QueryInterface: function(iid) {
    if (iid.equals(Components.interfaces.nsIWebProgressListener) ||
        iid.equals(Components.interfaces.nsISupportsWeakReference) ||
        iid.equals(Components.interfaces.nsISupports))
      return this;
    
    throw Components.results.NS_ERROR_NO_INTERFACE;
  },

  onStateChange: function(webProgress, request, stateFlags, status) {
    const WPL = Components.interfaces.nsIWebProgressListener;

    if (stateFlags & WPL.STATE_IS_REQUEST) {
      if (stateFlags & WPL.STATE_START) {
        this._requestsStarted++;
      } else if (stateFlags & WPL.STATE_STOP) {
        this._requestsFinished++;
      }
    }

    if (stateFlags & WPL.STATE_IS_NETWORK) {
      if (stateFlags & WPL.STATE_STOP) {
        this.onStatusChange(webProgress, request, 0, "Done");
        this._requestsStarted = this._requestsFinished = 0;
      }
    }
  },

  onProgressChange: function(webProgress, request, curSelf, maxSelf,
                             curTotal, maxTotal) {
  },

  onLocationChange: function(webProgress, request, location) {
  },

  onStatusChange: function(webProgress, request, status, message) {
    if (status == 0) {
      /* I haven't figured out why calling print2ps() without a small timeout makes the print
       * component fail. 
       */
      setTimeout('print2ps()', 500);
    }
  },

  onSecurityChange: function(webProgress, request, state) {
  }
};

function quit() {
	window.close();
}

// all progress notifications are done through the nsIWebProgressListener implementation...
var printProgressListener = {
    onStateChange: function(aWebProgress, aRequest, aStateFlags, aStatus) {
      const WPL = Components.interfaces.nsIWebProgressListener;
      if (aStateFlags & WPL.STATE_STOP)
      {
        // Without a small timeout, quitting right away makes xulrunner segfault.
	// Need to investigate
        setTimeout('quit()', 500);
      }
    },
    
    onProgressChange: function(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress) {
 	// ddump(aWebProgress+", "+ aRequest+", "+ aCurSelfProgress+", "+ aMaxSelfProgress+", "+ aCurTotalProgress+", "+ aMaxTotalProgress+"\n");

    },

    onLocationChange: function(aWebProgress, aRequest, aLocation) {
    },

    onStatusChange: function(aWebProgress, aRequest, aStatus, aMessage)
    {
    },

    onSecurityChange: function(aWebProgress, aRequest, state) {
    },

    QueryInterface : function(iid)
    {
     if (iid.equals(Components.interfaces.nsIWebProgressListener) || iid.equals(Components.interfaces.nsISupportsWeakReference))
      return this;
     
     throw Components.results.NS_NOINTERFACE;
    }
};

function print2ps() {
     try {
        var Tstart = new Date().getTime();
        var browser = document.getElementById("browser");
        var doc = browser.contentWindow.document;
        doc.chunks = [];
        doc.fonts = [];
        doc.getTextChunks = getTextChunks;
        doc.getTextChunks(doc);
        var xml  = [
           '<?xml version="1.0" encoding="ISO-8859-1"?>',
           '<!DOCTYPE html2xml SYSTEM "html2xml.dtd">',
           '',
           '<html2xml>',
           '<page number="1" position="absolute" top="0" left="0"'
           + ' height="' + doc.realHeight + '" width="' + doc.realWidth + '">'
        ];
        for (var family in doc.fonts) {
           for (var size in doc.fonts[family]) {
              for (var color in doc.fonts[family][size]) {
                 var id = doc.fonts[family][size][color];
                 xml.push('   <fontspec id="'+id+'" size="'+size+'" family="'+family+'" color="'+color+'"/>');
              }
           }
        }
        xml.push('');
        for (var i=0; i<doc.chunks.length; i++) {
           var chunk = doc.chunks[i];
           xml.push('<text left="'+chunk.left+'" top="'+chunk.top+'" width="'+chunk.width+'" height="'+chunk.height+'" font="'+chunk.font+'">'+chunk.text+'</text>');
        }
        xml.push('</page>');
        xml.push('</html2xml>');
        ddump(xml.join('\n'));
     } catch (e) { 
	 ddump(e); 
     }
     var Tend = new Date().getTime();
     ddump("html2xml finished: "+(Tend-Tstart));
};


function getTextChunks(el) {

   // recursion:
   if (el.childNodes) {
      // while traversing the DOM tree, we add absLeft, absTop, absWidth, absHeight properties:
      el.absLeft = el.offsetLeft;
      el.absTop = el.offsetTop;
      el.absWidth = el.offsetWidth;
      el.absHeight = el.offsetHeight;
      if (el.offsetParent) {
         el.absLeft += el.offsetParent.absLeft;
         el.absTop += el.offsetParent.absTop;
      }
      // merge adjactent text child nodes:
      el.normalize();
      for (var i = el.childNodes.length-1; i >= 0; i--) {
         this.getTextChunks(el.childNodes[i]);
      }
      if (el.offsetParent) {
         if (el.offsetParent.absWidth < el.offsetLeft + el.absWidth) 
            el.offsetParent.absWidth = el.offsetLeft + el.absWidth;
         if (el.offsetParent.absHeight < el.offsetTop + el.absHeight)
            el.offsetParent.absHeight = el.offsetTop + el.absHeight;
      }
      return;
   }
   // skip linebreak nodes between HTML elements:
   if (el.nodeValue == '\n') return;
   // skip nodes with width 0, like comments and <title> text: 
   if (el.parentNode.absWidth == 0) return;

   var chunk = {
      left : 0, // el.parentNode.absLeft,
      top : 0, // el.parentNode.absTop,
      width : 0, // el.parentNode.absWidth,
      height : 0 // el.parentNode.absHeight
   };
   // get font information:
   var style = this.defaultView.getComputedStyle(el.parentNode, null);
   var fontFamily = style && style.getPropertyValue('font-family');
   var fontSize = style && parseInt(style.getPropertyValue('font-size'));
   var fontColor = style && style.getPropertyValue('color');
   if (!this.fonts[fontFamily]) this.fonts[fontFamily] = [];
   if (!this.fonts[fontFamily][fontSize]) this.fonts[fontFamily][fontSize] = [];
   if (!this.fonts[fontFamily][fontSize][fontColor]) {
      if (!this._fontCounter) this._fontCounter = 0;
      this._fontCounter++;
      this.fonts[fontFamily][fontSize][fontColor] = this._fontCounter;
   }
   chunk.font = this.fonts[fontFamily][fontSize][fontColor];

   chunk.text = el.nodeValue;
   // if font is italic or bold, add the tags to the nodeValue (as pdftohtml does):
   if (style && style.getPropertyValue('font-weight') == 'bold') {
      chunk.text = '<b>'+chunk.text+'</b>';
   }
   if (style && style.getPropertyValue('font-style') == 'italic') {
      chunk.text = '<i>'+chunk.text+'</i>';
   }
   this.chunks.push(chunk);
}

function abspos(obj) {
	var curleft = curtop = 0;
	if (obj.offsetParent) {
		curleft = obj.offsetLeft
		curtop = obj.offsetTop
		while (obj = obj.offsetParent) {
			curleft += obj.offsetLeft
			curtop += obj.offsetTop
		}
	}
	return [curleft,curtop];
}

var listener;

function onload() {
  var browser = document.getElementById("browser");
  var nsCommandLine = window.arguments[0];
  nsCommandLine = nsCommandLine.QueryInterface(Components.interfaces.nsICommandLine);
  var from = nsCommandLine.getArgument(0);

  if (nsCommandLine.length != 2) {
    ddump("Wrong number of arguments. Expected <source> <destination>");
    window.close();
  }

  browser.loadURI(from, null, null);
  listener = new WebProgressListener();
  browser.addProgressListener(listener,
    Components.interfaces.nsIWebProgress.NOTIFY_ALL);
}

var browser = document.getElementById("browser");
var nsCommandLine = window.arguments[0];
nsCommandLine = nsCommandLine.QueryInterface(Components.interfaces.nsICommandLine);

if (nsCommandLine.length != 2) {
  ddump("Wrong number of arguments. Expected <source> <destination>");
  window.close();
}

var from = nsCommandLine.getArgument(0);
browser.loadURI(from, null, null);
addEventListener("load", onload, false);
