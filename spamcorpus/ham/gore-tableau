tab05-gore-nguyen.dviA Tableau Calculus with Automaton-Labelled
Formulae for Regular Grammar Logics
Rajeev Gor´e1 and Linh Anh Nguyen2
1 The Australian National University and NICTA
Canberra ACT 0200, Australia
Rajeev.Gore@anu.edu.au
2 Institute of Informatics, University of Warsaw
ul. Banacha 2, 02-097 Warsaw, Poland
nguyen@mimuw.edu.pl
Abstract. We present a sound and complete tableau calculus for theclass of regular grammar logics. Our tableau rules use a special featurecalled automaton-labelled formulae, which are similar to formulae of au-tomaton propositional dynamic logic. Our calculus is cut-free and hasthe analytic superformula property so it gives a decision procedure. Weshow that the known EXPTIME upper bound for regular grammar log-ics can be obtained using our tableau calculus. We also give an eﬀectiveCraig interpolation lemma for regular grammar logics using our calculus.
1
Introduction
Multimodal logics (and their description logic cousins) are useful in many ar-eas of computer science: for example, multimodal logics are used in knowledgerepresentation by interpreting [i]ϕ as “agent i knows/believes that ϕ is true”[7, 15, 1]. Grammar logics are normal multimodal logics characterised by “inclu-sion” axioms like [t1] . . . [th]ϕ ⊃ [s1] . . . [sk]ϕ, where [ti] and [sj] are modalitiesindexed by members ti and sj from some ﬁxed set of indices. Thus [1][2]ϕ → [1]ϕcaptures “if agent one knows that agent two knows ϕ, then agent one knows ϕ”.
Inclusion axioms correspond in a strict sense to grammar rules of the form
t1t2 . . . th → s1s2 . . . sk when the index set is treated as a set of atomic words andjuxtaposition is treated as word composition. Various reﬁnements ask whetherthe corresponding grammar is left or right linear, or whether the language gen-erated by the corresponding grammar is regular, context-free etc.
Grammar logics were introduced by Fari˜
nas del Cerro and Penttonen in [8]
and have been studied widely [3, 4, 20, 11, 5]. Baldoni et al. [3] gave a preﬁxedtableau calculus for grammar logics and used it to show that the general satisﬁa-bility problem of right linear grammar logics is decidable and the general satisﬁa-bility problem of context-free grammar logics is undecidable. But the techniquesof Baldoni et al. cannot be easily extended to regular grammar logics.
While trying to understand why the decidability proof by Baldoni et al.
[3, 2] cannot be naturally extended to left linear grammars, Demri [4] observedthat although right linear grammars generate the same class of languages asleft linear grammars, this correspondence is not useful at the level of regulargrammar logics. By using a transformation into the satisﬁability problem forpropositional dynamic logic (PDL), Demri was able to prove that the generalsatisﬁability problem of regular grammar logics is EXPTIME-complete and thatthe general satisﬁability problem of linear grammar logics is undecidable. In [5],Demri and de Nivelle gave a translation of the satisﬁability problem for grammarlogics with converse into the two-variable guarded fragment GF2 of ﬁrst-orderlogic, and showed that the general satisﬁability problem for regular grammarlogics with converse is in EXPTIME. The relationship between grammar logicsand description logics was considered, among others, in [11, 20].
Thus, various methods have been required to obtain complexity results and
decision procedures for regular grammar logics. We show that it is possible to givea (non-preﬁxed) tableau calculus which is a decision procedure for the whole classof regular grammar logics, and which also gives an estimate of the complexity ofthese logics. Eﬃcient tableaux for propositional multimodal (description) logicsare highly competitive with translation methods, so it is not at all obvious thatthe translation into GF2 from [5] is the best method for deciding these logics.
The naive way to encode inclusion axioms in a non-preﬁxed tableau calculus is
to add a rule like ([t]) shown below at left. But such rules cannot lead to a generaldecision procedure because there are well-known examples like transitivity [t]ϕ ⊃[t][t]ϕ, whose analogous rule is shown below at right, which immediately causean inﬁnite branch by adding [t][t]ϕ, and then [t][t][t]ϕ, and so on:
X; [t]ϕ
X; [t]ϕ
([t])
(4t)
X; [t]ϕ; [s1][s2] . . . [sk]ϕ
X; [t]ϕ; [t][t]ϕ
Our calculus uses a special feature called automaton-labelled formulae, which
are similar to formulae of APDL [10]. Informally, whenever a formula [t]ϕ is trueat a tableau node w, we add an automaton labelled formula that tracks themodal transitions from w. If a sequence of transitions leads to a tableau node u,and this sequence corresponds to a word s1s2 . . . sk recognised by the automatonlabelled formula, then we add the formula ϕ to u. This captures the eﬀect of therule ([t]) above left in a tractable manner since the inﬂuence of [t]ϕ being true atw can be computed directly from the content of the automaton labelled formulaein node u. Our tableau calculus is sound, complete, cut-free and has the analyticsuperformula property, so it is a decision procedure. As usual for tableau calculi,it allows eﬃcient implementation and good complexity estimation.
In Section 2, we deﬁne regular grammar logics and automaton-labelled for-
mulae. In Section 3, we present our tableau calculus for regular grammar logics,and prove it sound. In Section 4, we prove it complete. In Section 5, we provethat the general satisﬁability problem of regular grammar logics is in EXPTIMEby using our tableau rules in a systematic way. In Section 6, we use our calculusto prove eﬀective Craig interpolation for regular grammar logics. Further workand concluding remarks are in Section 7. The Appendix contains an example.
Acknowledgements: We are grateful to Pietro Abate, St´ephane Demri, Mar-cus Kracht and an anonymous reviewer for their helpful comments and pointers.
22
Preliminaries
2.1
Deﬁnitions for Multimodal Logics
Our modal language is built from two disjoint sets: MOD is a ﬁnite set ofmodal indices and PROP is a set of primitive propositions. We use p and qfor elements of PROP and use t and s for elements of MOD. Formulae of ourprimitive language are recursively deﬁned using the BNF grammar below:
ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕ ⊃ ϕ | [t]ϕ | t ϕ
A Kripke frame is a tuple W, τ, {Rt | t ∈ MOD} , where W is a nonempty
set of possible worlds, τ ∈ W is the current world, and each Rt is a binaryrelation on W , called the accessibility relation for [t] and t . If Rt(w, u) holdsthen we say that the world u is accessible from the world w via Rt.
A Kripke model is a tuple W, τ, {Rt | t ∈ MOD}, h , where W, τ, {Rt | t ∈
MOD} is a Kripke frame and h is a function mapping worlds to sets of primitivepropositions. For w ∈ W , the set of primitive propositions “true” at w is h(w).
A model graph is a tuple W, τ, {Rt | t ∈ MOD}, H , where W, τ, {Rt | t ∈
MOD} is a Kripke frame and H is a function mapping worlds to formula sets.We sometimes treat model graphs as models with H restricted to PROP.
Given a Kripke model M = W, τ, {Rt | t ∈ MOD}, h and a world w ∈ W ,
the satisfaction relation |= is deﬁned as usual for the classical connectives withtwo extra clauses for the modalities as below:
M, w |= [t]ϕ
iﬀ
∀v ∈ W.Rt(w, v) implies M, v |= ϕ
M, w |= t ϕ
iﬀ
∃v ∈ W.Rt(w, v) and M, v |= ϕ.
We say that ϕ is satisﬁed at w in M if M, w |= ϕ. We say that ϕ is satisﬁed
in M and call M a model of ϕ if M, τ |= ϕ.
If we consider only Kripke models, with no restrictions on Rt, we obtain a
normal multimodal logic with a standard Hilbert-style axiomatisation Kn.
Note: We now assume that formulae are in negation normal form, where ⊃ is
translated away and ¬ occurs only directly before primitive propositions. Everyformula ϕ has a logically equivalent formula ϕ which is in negation normal form.
2.2
Regular Grammar Logics
Recall that a ﬁnite automaton A is a tuple Σ, Q, I, δ, F , where Σ is the alphabet(for our case, Σ = MOD), Q is a ﬁnite set of states, I ⊆ Q is the set of initialstates, δ ⊆ Q×Σ ×Q is the transition relation, and F ⊆ Q is the set of acceptingstates. A run of A on a word s1 . . . sk is a ﬁnite sequence of states q0, q1, . . . , qksuch that q0 ∈ I and δ(qi−1, si, qi) holds for every 1 ≤ i ≤ k. It is an acceptingrun if qk ∈ F . We say that A accepts word w if there exists an accepting run ofA on w. The set of all words accepted/recognised by A is denoted by L(A).
Given two binary relations R1 and R2 over W , their relational composition
R1 ◦ R2 = {(x, y) | ∃y ∈ W.R1(x, y) &amp; R2(y, z)} is also a binary relation over W .
3A grammar logic is a multimodal logic extending Kn with “inclusion axioms”
of the form [t1] . . . [th]ϕ ⊃ [s1] . . . [sk]ϕ, where {t1, . . . th, s1, . . . sk} ⊆ MOD.Each inclusion axiom corresponds to the restriction Rs ◦. . .◦R
⊆ R ◦. . .◦R
1
sk
t1
th
on accessibility relations where the corresponding side stands for the identityrelation if k = 0 or h = 0. For a grammar logic L, the L-frame restrictions arethe set of all such corresponding restrictions. A Kripke model is an L-model if itsframe satisﬁes all L-frame restrictions. A formula ϕ is L-satisﬁable if there existsan L-model satisfying it. A formula ϕ is L-valid if it is satisﬁed in all L-models.
An inclusion axiom [t1] . . . [th]ϕ ⊃ [s1] . . . [sk]ϕ can also be seen as the gram-
mar rule t1 . . . th → s1 . . . sk where the corresponding side stands for the emptyword if k = 0 or h = 0. Thus the inclusion axioms of a grammar logic L capturea grammar G(L). Here we do not distinguish terminal symbols and nonterminalsymbols. G(L) is context-free if its rules are of the form t → s1 . . . sk, and is reg-ular if it is context-free and for every t ∈ MOD there exists a ﬁnite automatonAt that recognises the words derivable from t using G(L).
A regular grammar logic L is a grammar logic whose inclusion axioms cor-
respond to grammar rules that collectively capture a regular grammar G(L). Aregular language is traditionally speciﬁed either by a regular expression or bya left/right linear grammar or by a ﬁnite automaton. The ﬁrst two forms canbe transformed in PTIME to an equivalent ﬁnite automaton that is at mostpolynomially larger. But there is no syntactic way to specify the class of regular(context-free) grammars, and checking whether a context-free grammar gener-ates a regular language is undecidable (see, e.g., [14]). Hence, we cannot computethese automata if we are given an arbitrary regular grammar logic. We thereforeassume that for each t ∈ MOD we are given an automaton At recognising thewords derivable from t using G(L). These are the automata specifying L.
Lemma 1. Let L be a regular grammar logic and let {At | t ∈ MOD} be theautomata specifying L. Then the following conditions are equivalent:
(i) the word s1 . . . sk is accepted by At(ii) the formula [t]ϕ ⊃ [s1] . . . [sk]ϕ is L-valid(iii) the inclusion Rs ◦. . .◦R
⊆ R
1
sk
t is a consequence of the L-frame restrictions.
Proof. The equivalence (ii) ⇔ (iii) is well-known from correspondence theory[19]. The implication (i) ⇒ (ii) follows by induction on the length of the deriva-tion of s1 . . . sk from t by the grammar G(L), using substitution, the K-axiom[t](ϕ ⊃ ψ) ⊃ ([t]ϕ ⊃ [t]ψ) and the modal necessitation rule ϕ/[t]ϕ. The im-plication (iii) ⇒ (i) follows by induction on the length of the derivation ofRs ◦ . . . ◦ R
⊆ R
1
sk
t from the L-frame restrictions. See also [3, 4] for details.
Example 1. Let MOD = {1, . . . , m} for a ﬁxed m. Consider the grammar logicwith the inclusion axioms [i]ϕ ⊃ [j][i]ϕ for any i, j ∈ MOD and [i]ϕ ⊃ [j]ϕ ifi &gt; j. This is a regular grammar logic because the set of words derivable from iusing the corresponding grammar is {1, . . . , m}∗.{1, . . . , i}. This set is recognisedby the automaton Ai = MOD, {p, q}, {p}, δi, {q} with δi = {(p, j, p) | 1 ≤ j ≤m} ∪ {(p, j, q) | 1 ≤ j ≤ i}. Note that the corresponding grammar is not “linear”in that at most one symbol in the right hand side of a rule can be nonterminal.
42.3
Automaton-Labelled Formulae
If A is a ﬁnite automaton, Q is a subset of the states of A, and ϕ is a formulain the primitive language then (A, Q) : ϕ is an automaton-labelled formula.
Fix a regular grammar logic L and let {At = MOD, Qt, It, δt, Ft | t ∈
MOD} be the automata specifying L. Let δt(Q, s) = {q | ∃q ∈ Q.(q, s, q ) ∈ δt}be the states which can be reached from Q via an s-transition using At. Theintuitions of automaton labelled formulae are as follows:
Tagging: A formula of the form [t]ϕ in a world u is represented by (At, It) : ϕ.Tracking: If (At, Q) : ϕ occurs at u and R(u, v) holds then we add the formula
(At, δt(Q, s)) : ϕ to v. In particular, if (At, It) : ϕ appears in world u andRs(u, v) holds then we add (At, δt(It, s)) : ϕ to the world v.
Acceptance: If (At, Q) : ϕ occurs at u and Q contains an accepting state of At,
then we add ϕ to u.
The formal semantics of automaton-labelled formulae are deﬁned as fol-
lows. Let ε be the empty word and deﬁne δt(Q, ε) = Q and δt(Q, s1 . . . sk) =δt(δt(Q, s1), s2 . . . sk). If M is a Kripke model, w is a world of M , and At =
MOD, Qt, It, δt, Ft is an automaton, then M, w |= (At, Q) : ϕ iﬀ there ex-
ist worlds w0, . . . , wk = w (of M ) and indices s1, . . . , sk ∈ MOD such thatM, w0 |= [t]ϕ, Rs (w
i
i−1, wi) holds for 1 ≤ i ≤ k, and δt(It, s1 . . . sk) = Q.
Pictorially: M, w |= (At, Q) : ϕ iﬀ
w
s1
s2
sk
0
// w1
// · · ·
wk−1
// wk = w
[t]ϕ
δ(It, s1)
· · ·
δ(It, s1 . . . sk−1)
δ(It, s1 . . . sk) = Q
We can see the soundness of these deﬁnitions by the following inter-derivable
sequence of validities of multimodal tense logic which use the residuation prop-erties of s −1 and [s] shown at right where s −1 is the converse of s :
[t]ϕ ⊃ [s1][s2] . . . [sk]ϕ
s −1
1
[t]ϕ ⊃ [s2] . . . [sk]ϕ
ϕ ⊃ [s]ψ
. . .
s −1ϕ ⊃ ψ
s −1
−1
k
. . . s1
[t]ϕ ⊃ ϕ
That is, if we want to ensure that [t]ϕ ⊃ [s1][s2] . . . [sk]ϕ is valid, then it
suﬃces to ensure that s −1
−1
k
. . . s1
[t]ϕ ⊃ ϕ is valid instead. But converse
modalities are not part of our oﬃcial language so we use the occurrence of [t]ϕat w0 to start an automaton At which tracks the following constraint: ϕ mustbe true at any world w reachable from w0 by the path/word s1 . . . sk.
Our automaton-labelled formulae are similar to formulae of automaton
propositional dynamic logic (APDL) [10]. A formula involving automata inAPDL is of the form [A]ϕ, where A is a ﬁnite automata with one initial state
5and one accepting state. An automaton labelled formula like our (At, Q) : ϕ withQ = {q1, q2, . . . , qk} can be simulated by the APDL formula [B1]ϕ ∨ . . . ∨ [Bk]ϕwhere each Bi is the automaton At restricted to start at the initial state qi. Thusour formulation uses a more compact representation in which APDL formulaethat diﬀer only in their initial state are grouped together. Moreover, we do nottreat diﬀerent “states” of an automaton as diﬀerent automata. Our compactrepresentation not only saves memory but also increases eﬃciency of deduction.
From now on, by a formula we mean either a formula in the primitive lan-
guage (as deﬁned in Section 2.1) or an automaton-labelled formula.
2.4
Deﬁnitions for Tableau Calculi
As in our previous works on tableau calculi [9, 17], our tableau formulation tracetheir roots to Hintikka via [18]. A tableau rule σ consists of a numerator Nabove the line and a (ﬁnite) list of denominators D1, D2, . . . , Dk (below theline) separated by vertical bars. The numerator is a ﬁnite formula set, and so iseach denominator. As we shall see later, each rule is read downwards as “if thenumerator is L-satisﬁable, then so is one of the denominators”. The numerator ofeach tableau rule contains one or more distinguished formulae called the principalformulae. A tableau calculus CL for a logic L is a ﬁnite set of tableau rules.
A CL-tableau for X is a tree with root X whose nodes carry ﬁnite formula
sets obtained from their parent nodes by instantiating a tableau rule with theproviso that if a child s carries a set Z and Z has already appeared on the branchfrom the root to s then s is an end node.
Let ∆ be a set of tableau rules. We say that Y is obtainable from X by
applications of rules from ∆ if there exists a tableau for X which uses only rulesfrom ∆ and has a node that carries Y . A branch in a tableau is closed if its endnode carries only ⊥. A tableau is closed if every one of its branches is closed. Atableau is open if it is not closed. A ﬁnite formula set X in the primitive languageis said to be CL-consistent if every CL-tableau for X is open. If there is a closedCL-tableau for X then we say that X is CL-inconsistent.
A tableau calculus CL is sound if for all ﬁnite formula sets X in the primitive
language, X is L-satisﬁable implies X is CL-consistent. It is complete if for allﬁnite formula sets X in the primitive language, X is CL-consistent implies Xis L-satisﬁable. Let σ be a rule of CL. We say that σ is sound w.r.t. L if forevery instance σ of σ, if the numerator of σ is L-satisﬁable then so is one ofthe denominators of σ . Any CL containing only rules sound w.r.t. L is sound.
3
A Tableau Calculus for Regular Grammar Logics
Fix a regular grammar logic L and let {At = MOD, Qt, It, δt, Ft | t ∈ MOD}be the automata specifying L. Recall that formulae are in negation normal form.We use X for a formula set, and semicolon to separate elements of a formulaset. We have deliberately used “s.t.” for “such that” in the set notation of the
6X; p; ¬p
X; ϕ ∧ ψ
X; ϕ ∨ ψ
(⊥)
⊥
(∧)
(∨)
X; ϕ; ψ
X; ϕ | X; ψ
X; [t]ϕ
X; (A
(label)
(add)
t, Q): ϕ
if Q ∩ F
X; (A
t = ∅
t , It): ϕ
X; (At, Q): ϕ; ϕ
X; t ϕ
(trans) {(As, δs(Q,t)):ψ s.t. (As, Q):ψ ∈ X}; ϕ
Fig. 1. Tableau Rules
denominator of the (trans)-rule because we use colon in automaton-labelled for-mulae and the alternative | indicates a branching rule! The tableau calculus CLis given in Figure 1. The ﬁrst ﬁve rules are static rules, and the last rule is atransitional rule. An example is in the appendix.
A tableau calculus CL has the analytic superformula property iﬀ to every
ﬁnite set X we can assign a ﬁnite set X∗ which contains all formulae that may
CL
appear in any tableau for X. We write Sf (ϕ) for the set of all subformulae of ϕ,and Sf (X) for the set
Sf (ϕ)∪{⊥}. Our calculus has the analytic superfor-
ϕ∈X
mula property, with X∗ = Sf (X) ∪ {(A
CL
t, Q): ϕ s.t. [t]ϕ ∈ Sf (X ) and Q ⊆ Qt}.
Lemma 2. The tableau calculus CL is sound.
Proof. We show that CL contains only rules sound w.r.t. L as follows. Supposethat the numerator of the considered rule is satisﬁed at a world w in a modelM = W, τ, {Rt | t ∈ MOD}, h . We have to show that at least one of thedenominators of the rule is also satisﬁable. For the static rules, we show thatsome denominator is satisﬁed at w itself. For the transitional rule (trans), weshow that its denominator is satisﬁed at some world reachable from w via Rt.
(⊥), (∧), (∨): These cases are obvious.(label): If M, w |= X; [t]ϕ then M, w |= (At, It): ϕ by deﬁnition.(add): Suppose that M, w |= X; (At, Q): ϕ and Q ∩ Ft = ∅. By deﬁnition, there
exist worlds w0, . . . , wk−1, wk = w and indices s1, . . . , sk ∈ MOD such thatM, w0 |= [t]ϕ, and Rs (w
i
i−1, wi) holds for 1 ≤ i ≤ k, and δt(It, s1 . . . sk ) = Q.
Since Q ∩ Ft = ∅, the word s1 . . . sk is accepted by At. By Lemma 1, itfollows that M, w0 |= [s1] . . . [sk]ϕ. Since w = wk and Rs (w
i
i−1 , wi) holds
for 1 ≤ i ≤ k, we must have M, w |= ϕ.
(trans): Suppose that M, w |= X; t ϕ. Then there exists some u such that
Rt(w, u) holds and M, u |= ϕ. For each (As, Q): ψ ∈ X, we have M, w |=(As, Q): ψ, and by the semantics of automaton-labelled formulae, it followsthat M, u |= (As, δs(Q, t)): ψ. Hence, the denominator is satisﬁed at u.
4
Completeness
We prove completeness of our calculus via model graphs following [18, 9, 16, 17]by giving an algorithm that accepts a ﬁnite CL-consistent formula set X in theprimitive language and constructs an L-model graph (deﬁned in Section 4.2) forX that satisﬁes every one of its formulae at the appropriate world.
74.1
Saturation
In the rules (∧), (∨), (label) the principal formula does not occur in the denomi-nators. For any of these rules δ, let δ denote the rule obtained from δ by addingthe principal formula to each of the denominators. Let SCL denote the set ofstatic rules of CL with (∧), (∨), (label) replaced by (∧ ), (∨ ), (label ). For everyrule of SCL, except (⊥), the numerator is included in each of the denominators.
For a ﬁnite CL-consistent formula set X, a formula set Y is called a CL-
saturation of X if Y is a maximal CL-consistent set obtainable from X by ap-plications of the rules of SCL. A set X is closed w.r.t. a tableau rule if applyingthat rule to X gives back X as one of the denominators.
Lemma 3. Let X be a ﬁnite CL-consistent formula set and Y a CL-saturationof X. Then X ⊆ Y ⊆ X∗
C
and Y is closed w.r.t. the rules of SCL. Furthermore,
L
there is an eﬀective procedure that, given a ﬁnite CL-consistent formula set X,constructs some CL-saturation of X.
Proof. It is clear that X ⊆ Y ⊆ X∗ . Observe that if a rule of SCL is ap-
CL
plicable to Y , then one of the corresponding instances of the denominators isCL-consistent. Since Y is a CL-saturation, Y is closed w.r.t. the rules of SCL.
We construct a CL-saturation of X as follows: let Y = X; while there is some
rule δ of SCL applicable to Y such that one of its corresponding denominatorinstance Z is CL-consistent and strictly contains Y , set Y = Z. At each iteration,Y ⊂ Z ⊆ X∗ . Hence the above process always terminates. It is clear that the
CL
resulting set Y is a CL-saturation of X.
4.2
Proving Completeness via Model Graphs
A model graph is an L-model graph if its frame is an L-frame. An L-model graph
W, τ, {Rt | t ∈ MOD}, H is saturated if every w ∈ W satisﬁes:
And: if ϕ ∧ ψ ∈ H(w) then {ϕ, ψ} ⊆ H(w);Or: if ϕ ∨ ψ ∈ H(w) then ϕ ∈ H(w) or ψ ∈ H(w);Box: if [t]ϕ ∈ H(w) and Rt(w, u) holds then ϕ ∈ H(u);Dia: if t ϕ ∈ H(w) then there exists a u ∈ W such that Rt(w, u) and ϕ ∈ H(u).
A saturated model graph is consistent if no world contains ⊥, and no world
contains {p, ¬p}. Our model graphs merely denote a data structure, while Raut-enberg’s model graphs are required to be saturated and consistent.
Lemma 4. If M = W, τ, {Rt | t ∈ MOD}, H is a consistent saturated L-modelgraph, then M satisﬁes all formulae of H(τ ) which are in the primitive language.
Proof. By proving ϕ ∈ H(w) implies M, w |= ϕ by induction on the length of ϕ.
Given a ﬁnite CL-consistent set X in the primitive language, we construct a
consistent saturated L-model graph M = W, τ, {Rt | t ∈ MOD}, H such thatX ⊆ H(τ ), thereby giving an L-model for X.
84.3
Constructing Model Graphs
In the following algorithm, the worlds of the constructed model graph are markedeither as unresolved or as resolved.
Algorithm 1
Input: a ﬁnite CL-consistent set X of formulae in the primitive language.
Output: an L-model graph M = W, τ, {Rt | t ∈ MOD}, H satisfying X.
1. Let W = {τ }, H(τ ) be a CL-saturation of X, and Rt = ∅ for all t ∈ MOD.
Mark τ as unresolved.
2. While there are unresolved worlds, take one, say w, and do the following:
(a) For every formula t ϕ in H(w):
i. Let Y = {(As, δs(Q, t)): ψ s.t. (As, Q): ψ ∈ H(w)} ∪ {ϕ} be the result
of applying rule (trans) to H(w), and let Z be a CL-saturation of Y .
ii. If ∃u ∈ W on the path from the root to w with H(u) = Z, then add
the pair (w, u) to R . Otherwise, add a new world w
t
ϕ with content Z
to W , mark it as unresolved, and add the pair (w, wϕ) to R .
t
(b) Mark w as resolved.
3. Let Rt be the least extension of R for t ∈ MOD such that W, τ, {R
t
t | t ∈
MOD} is an L-frame.
This algorithm always terminates: eventually, for every w, either w contains
no t -formulae, or there exists an ancestor with H(u) = Z at Step 2(a)ii becauseall CL-saturated sets are drawn from the ﬁnite and ﬁxed set X∗ .
CL
Lemma 5. Suppose Rt(w, u) holds via Step 3. Then there exist w0, . . . , wk inM with w0 = w, wk = u, and indices s1, . . . , sk ∈ MOD such that Rs (wi−1, wi)
i
holds for 1 ≤ i ≤ k, and Rs ◦. . .◦R
⊆ R
1
sk
t follows from the L-frame restrictions.
Proof. By induction on number of inferences in deriving Rt(w, u) when extendingR
◦
⊆
s to Rs for s ∈ MOD, with L-frame restrictions of the form Rt
. . .◦R
R
1
th
s.
4.4
Completeness Proof
Lemma 6. Let X be a ﬁnite CL-consistent set of formulae in the primitive lan-guage and M = W, τ, {Rt | t ∈ MOD}, H be the model graph for X constructedby Algorithm 1. Then M is a consistent saturated L-model graph satisfying X.
Proof. It is clear that M is an L-model graph and for any w ∈ W , the set H(w) isCL-consistent. We want to show that M is a saturated model graph. It suﬃces toshow that, for every w, u ∈ W , if [t]ϕ ∈ H(w) and Rt(w, u) holds then ϕ ∈ H(u).Suppose that [t]ϕ ∈ H(w) and Rt(w, u) holds. By Lemma 5, there exist worldsw0, . . . , wk with w0 = w, wk = u and indices s1, . . . , sk ∈ MOD such thatR
◦
⊆
s (wi−1, wi) holds for 1 ≤ i ≤ k and Rs
. . . ◦ Rs
Rt is a consequence of the
i
1
k
L-frame restrictions. Since H(w) is a CL-saturation, we have that (At, It): ϕ ∈H(w). By Step 2a of Algorithm 1, (At, δt(It, s1 . . . si)): ϕ ∈ H(wi) for 1 ≤ i ≤ k.Thus (At, δt(It, s1 . . . sk)): ϕ ∈ H(u). Since Rs ◦. . .◦R
⊆ R
1
sk
t is a consequence of
the L-frame restrictions, by Lemma 1, the word s1 . . . sk is accepted by At. Henceδt(It, s1 . . . sk) ∩ Ft = ∅. It follows that ϕ ∈ H(u), since H(u) is a CL-saturation.
9The following theorem follows from Lemmas 2 and 6.
Theorem 1. The tableau calculus CL is sound and complete.
5
Complexity
The satisﬁability problem of a logic L is to check the L-satisﬁability of an inputformula ϕ. The general satisﬁability problem of a class C of logics is to checkL-satisﬁability of an input formula ϕ in an input logic L ∈ C.
Demri [4] proved that the general satisﬁability problem of regular grammar
logics is EXPTIME-complete by a transformation into satisﬁability for PDL. Wenow obtain the upper bound EXPTIME using our tableaux calculus.
We need a rule (∪) to coalesce (At, Q): ϕ and (At, Q ): ϕ into (At, Q ∪ Q ): ϕ
X ; (A
(∪)
t, Q): ϕ ; (At, Q ): ϕ
X ; (At, Q ∪ Q ): ϕ
Observe that X; (At, Q): ϕ; (At, Q ): ϕ is CL-consistent iﬀ X; (At, Q ∪ Q ): ϕ isCL-consistent. This follows from the facts that δt(Q, s) ∪ δt(Q , s) = δt(Q ∪ Q , s)and ((Q ∩ Ft = ∅) ∨ (Q ∩ Ft = ∅)) ≡ ((Q ∪ Q ) ∩ Ft = ∅). Thus, rule (∪) canbe added to CL as a static rule, and used whenever possible without aﬀectingsoundness and completeness. Let CLu be CL plus (∪).
Allowing (∪) requires a change in the semantics of automaton-labelled formu-
lae to: if M is a Kripke model, w is a world of M , and At = MOD, Qt, It, δt, Ftis an automaton, then M, w |= (At, Q) : ϕ iﬀ for every q ∈ Q there existworlds w0, . . . , wk−1, wk = w (of M ) and indices s1, . . . , sk ∈ MOD such thatM, w0 |= [t]ϕ, and Rs (w
i
i−1, wi) holds for 1 ≤ i ≤ k, and q ∈ δt(It, s1 . . . sk ) ⊆ Q.
Let L be a regular logic and X a ﬁnite formula set in the primitive language.
Let n be the sum of the sizes of the formulae in X and the sizes of the automataspecifying L. To check whether X is L-satisﬁable we can search for a closedCLu-tableau for X, or equivalently, examine an and-or tree for X constructedby using Algorithm 1 to apply our CLu-tableau rules in a systematic way. In sucha tree, and-branching is caused by all possible applications of rule (trans), whileor-branching is caused by an application of rule (∨). The other CLu-tableaurules, including (∪), are applied locally for each node whenever possible.
There are at most O(n) unlabelled subformulae of X, and at most 2O(n)
diﬀerent labels. By using the rule (∪) whenever possible, each subformula of Xoccurs in a node with at most two labels, so a node contains at most 2n i.e. O(n)labelled formulae. Hence there are at most (2O(n))O(n) = 2O(n2) diﬀerent nodes.Without the rule (∪), there are at most 22O(n) diﬀerent nodes, which breaksEXPTIME worst-case complexity, so the (∪) rule is absolutely essential. But itis not necessary for the satisﬁability problem of a ﬁxed logic.
Algorithm 1 terminates in general because it checks for repeated ancestors:
this check is built into the deﬁnition of an end-node, and also in Step 2(a)ii. Thusthe same node can appear on multiple branches. In the worst case, Algorithm 1therefore requires 22O(n2) time. We therefore reﬁne it into Algorithm 2 below:
10Algorithm 2
Input: a ﬁnite set X of formulae in the primitive language.
Output: a ﬁnite graph G = (V, E)
1. Let G =&lt; V, E &gt;=&lt; {X}, ∅ &gt;, and mark X as unresolved.2. While V contains unresolved nodes, take one, say n, and do:
(a) If (∪) is applicable to n then apply it to obtain denominator d1
(b) Else if any static rule of CL is applicable to n then apply it to obtain
denominator(s) d1 (and possibly d2)
(c) Else, for every formula t ϕi in n, let di = {(As, δs(Q, t)): ψi s.t. (As, Q):
ψi ∈ n} ∪ {ϕi} be the denominator obtained by applying (trans) to n
(d) Mark n as resolved (n is an or/and node if the applied rule is/isn’t (∨))
(e) For every denominator d = d1, · · · , dk:
i. If some proxy c ∈ V has c = d, then add the edge (n, c) to E
ii. Else add d to V , add (n, d) to E, and mark d as unresolved.
Algorithm 2 builds an and-or graph G monotonically by “caching” previously
seen nodes (but not their open/closed status). The graph G contains a node dfor every applicable static rule denominator, not just their CL-saturation as inAlgorithm 1. Each node appears only once because repetitions are representedby “cross-tree” edges to their ﬁrst occurrence, so G has at most 2O(n2) nodes.
We now make passes of the and-or graph G, marking nodes as false in a
monotonic way. In the ﬁrst pass we mark the node containing ⊥, if it exists, sincefalse captures inconsistency. In each subsequent pass we mark any unmarked or-node with two false-marked children, and mark any unmarked and-node with atleast one false-marked child. We stop making passes when some pass marks nonode. Otherwise, we must terminate after 2O(n2) passes since the root must thenbe marked with false. Note that once a node is marked with false this mark isnever erased. Finally, mark all non-false nodes with true giving graph Gf .
Lemma 7. If node n ∈ Gf is marked false then n is CLu-inconsistent.
Proof. By induction on the number of passes needed to mark n with false.
Lemma 8. If a node n ∈ Gf is marked true then it is CLu-consistent.
Proof. An easy proof is to take the sub-graph Gn generated by n; replace eachsequence of true-marked static rule denominators by one true-marked node con-taining their union, which represents their CLu-saturation; and turn the resultingsub-graph into an L-frame by appropriately extending it as in Step 3 of Algo-rithm 1. For each node x, putting p ∈ h(x) iﬀ p ∈ x gives an L-model for n since:all eventualities in a true-marked node are fulﬁlled by its children, and these areguaranteed to be marked true; and each true-marked or-node has at least onetrue-marked child. By the completeness of CLu, every CLu-tableau for n mustbe open. A slightly trickier proof converts Gn into an and-or tree by mimickingthe rule applications from Gn but unwinding edges to non-ancestor-proxies bymaking a copy of the proxy. This reproduces all CLu-tableaux for n constructibleby Algorithm 1 (sic) and each one is open by its construction.
Algorithm 2 and the creation of Gf runs in time (2O(n2))2 = 22.O(n2) and so
the general satisﬁability problem of regular grammar logics is in EXPTIME.
11(I⊥) Z
Z ; p; ¬p
(I⊥) Z; p p Z ; ¬p
ζ
ζ ∧ ξ
Z
Z ; ϕ ∧ ψ
Z
Z ; ϕ ∨ ψ
(I∧)
(I∨)
ζ
ζ
ξ
Z
Z ; ϕ; ψ
Z
Z ; ϕ | Z
Z ; ψ
ζ
ζ
Z
Z ; [t]ϕ
Z
Z ; (At, Q): ϕ
(Ilabel)
(Iadd)
if Q ∩ F
ζ
ζ
t = ∅
Z
Z ; (At, It): ϕ
Z
Z ; (At, Q): ϕ; ϕ
[t]ζ
Z
Z ; t ϕ
(Itrans)
ζ
{(As, δs(Q, t)): ψ s.t. (As, Q): ψ ∈ Z} {(As, δs(Q, t)): ψ s.t. (As, Q): ψ ∈ Z }; ϕ
Fig. 2. Rules of the Calculus for Interpolation
6
Eﬀective Interpolation
We say that ζ is an interpolation formula in L for the formula ϕ ⊃ ψ if allprimitive propositions of ζ are common to ϕ and ψ, and ϕ ⊃ ζ and ζ ⊃ ψ areboth L-valid. The Craig interpolation lemma for L states that if ϕ ⊃ ψ is L-valid,then there exists an interpolation formula in L for ϕ ⊃ ψ. This lemma is eﬀectiveif the proof of the lemma actually constructs the interpolation formula.
Assume our language contains
with the usual semantics. We prove eﬀective
Craig interpolation for all regular grammar logics using the method of [16].
Our tableau calculi are refutation calculi, so we use an indirect formulation
of interpolation. Given two sets X and Y of formulae, and using ζ to denote thenegation normal form of ¬ζ, we say that ζ is an interpolation formula w.r.t. CLfor the pair X, Y , and also that X ζ Y is CL-valid, if: all primitive propositionsof ζ are common to X and Y , the formula ζ does not contain automaton-labelledformulae, and the sets X; ζ and ζ; Y are both CL-inconsistent. Since CL is soundand complete, it follows that if ϕ ζ ψ is CL-valid, then ϕ ⊃ ζ and ζ ⊃ ψ areboth L-valid, and hence that ζ is an interpolation formula in L for ϕ ⊃ ψ.
We now show that for any ﬁnite formula sets X and Y , if X; Y is CL-
inconsistent, then there exists an interpolation formula w.r.t. CL for the pair
X, Y . It follows that the Craig interpolation lemma holds for L.
Observe that Y ϕ X is CL-valid iﬀ X ϕ Y is CL-valid. We call Y ϕ X the
reverse form of X ϕ Y .
The rule (Iδ) below left is an interpolation rule if the inference step below
right is an instance of the tableau rule with name (δ):
N ϕ N
N ; N
(Iδ) D ϕ1
ϕk
1
D |
|
1
. . . | Dk
D
D
. . . | D
k
1; D1
k; Dk
Provided that (δ) is a CL-tableau rule, the interpolation rule (Iδ) is CL-sound ifCL-validity of all D
ϕ1
ϕk
1
D1, . . . , Dk
D implies CL-validity of N ϕ N .
k
12Figure 2 contains the interpolation rules obtained from the tableau rules for
regular grammar logics. Each tableau rule of CL except (I⊥) has one corre-sponding interpolation rule. Rule (⊥) has an interpolation rule for each of itstwo principal formulae but these rules have no denominator because it is notnecessary. Rule (∪) has no interpolation rule since it is just an optimisation rule.
Lemma 9. The above interpolation rules are CL-sound.
Proof. We consider (Itrans) only, the others are similar. Let X = {(As, δs(Q, t)):ψ s.t. (As, Q): ψ ∈ Z} and Y = {(As, δs(Q, t)): ψ s.t. (As, Q): ψ ∈ Z }. Supposethat X ζ Y ; ϕ is CL-valid. Thus, both X; ζ and ζ; Y ; ϕ are CL-inconsistent,and have closed CL-tableaux. We show that Z [t]ζ Z ; t ϕ is CL-valid by givingclosed CL-tableaux for both Z; t ζ and [t]ζ; Z ; t ϕ:
[t]ζ; Z ; t ϕ
(label)
(At, It): ζ; Z ; t ϕ
(trans)
(At, δt(It, t)): ζ; Y ; ϕ
(add)
Z; t ζ
(A
(
t, δt(It, t)): ζ ; ζ ; Y ; ϕ
trans)
(wk)
X; ζ
ζ; Y ; ϕ
(assumption)
(assumption)
⊥
⊥
Applying (add) above right is justiﬁed because δt(It, t) ∩ Ft = ∅ since At
accepts word t. Also, the rule (wk) of weakening is obviously admissible.
These rules build the numerator’s interpolant from those of the denominators.
Using Lemma 9, and the technique of [16, Lemmas 13 and 14] we obtain:
Theorem 2. Regular grammar logics enjoy eﬀective Craig interpolation.
7
Further Work and Conclusions
Our main contribution is a tableau calculus that forms a decision procedurefor the whole class of regular grammar logics. Our automaton-labelled formulaeare similar to formulae of APDL [10], but with a more compact representationusing sets of states instead of single states. We have shown that automaton-labelled formulae work well with the traditional techniques of proving soundnessand completeness. Our calculus gives a simple estimate of the upper complexitybound of regular grammar logics, and can be used to obtain eﬀective Craiginterpolation for these logics. We have since found that Craig interpolation forregular grammar logics follows from [13, Corollary B4.1] and [12].
The preﬁxed tableaux of Baldoni et al. give a decision procedure only for
right linear logics. A preﬁxed calculus that simulates our calculus would be lesseﬃcient because it would repeatedly search the current branch for computation,not just for loops as in our case. Moreover, it is well-known that loop checkingcan be done eﬃciently using, e.g., a hash table. Finally, the transformation of
13Demri and de Nivelle into GF2 is based on states, but not sets of states, whichreduces eﬃciency. Also their resulting formula sets are much larger because theykeep a copy of the formulae deﬁning an automaton At for each formula [t]ϕ,whereas we can keep only t and Q for (At, Q) in (At, Q): ϕ. Similar observationshave been stated for formulae of APDL.
By propagating false “on the ﬂy”, we believe we can prove global caching
sound for checking satisﬁability in multimodal K with global assumptions i.e.“checking ALC-satisﬁability of a concept w.r.t. a TBox with general axioms” [6].
References
1. F. Baader and U. Sattler. An overview of tableau algorithms for description logics.
Studia Logica, 69:5–40, 2001.
2. M. Baldoni. Normal Multimodal Logics: Automatic Deduction and Logic Program-
ming Extension. PhD thesis, Dip. di Inf., Univ. degli Studi di Torino, Italy, 1998.
3. M. Baldoni, L. Giordano, and A. Martelli. A tableau for multimodal logics and
some (un)decidability results. In TABLEAUX’1998, LNCS 1397:44-59, 1998.
4. S. Demri. The complexity of regularity in grammar logics and related modal logics.
Journal of Logic and Computation, 11(6):933–960, 2001 (see also the long version).
5. S. Demri and H. de Nivelle. Deciding regular grammar logics with converse through
ﬁrst-order logic. Journal of Logic, Language and Information, 2005. To appear.
6. F Donini and F Massacci. EXPTIME tableaux for ALC. Artiﬁcial Intelligence,
124:87–138, 2000.
7. R Fagin, J Y Halpern, Y Moses, and M Y Vardi. Reasoning About Knowledge.
MIT Press, 1995.
8. L. Fari˜
nas del Cerro and M. Penttonen. Grammar logics. Logique et Analyse,
121-122:123–134, 1988.
9. R. Gor´e. Tableau methods for modal and temporal logics. In D’Agostino et al,
editor, Handbook of Tableau Methods, pages 297–396. Kluwer, 1999.
10. D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. MIT Press, 2000.11. I. Horrocks and U. Sattler. Decidability of SHIQ with complex role inclusion
axioms. Artiﬁcial Intelligence, 160(1-2):79–104, 2004.
12. M. Kracht. Reducing modal consequence relations. JLC, 11(6):879–907, 2001.13. M. Marx and Y. Venema. Multi-dimensional Modal Logic. Kluwer, 1997.14. A. Mateescu and A. Salomaa. Formal languages: an introduction and a synopsis.
In Handbook of Formal Languages - Volume 1, pages 1–40. Springer, 1997.
15. J.-J.Ch. Meyer and W. van der Hoek. Epistemic Logic for Computer Science and
Artiﬁcial Intelligence. Cambridge University Press, 1995.
16. L.A. Nguyen. Analytic tableau systems and interpolation for the modal logics
KB, KDB, K5, KD5. Studia Logica, 69(1):41–57, 2001.
17. L.A. Nguyen. Analytic tableau systems for propositional bimodal logics of knowl-
edge and belief. In TABLEAUX 2002, LNAI 2381:206-220. Springer, 2002.
18. W. Rautenberg. Modal tableau calculi and interpolation. JPL, 12:403–423, 1983.19. J. van Benthem. Correspondence theory. In D. Gabbay and F. Guenthner, editors,
Handbook of Philosophical Logic, Vol II, pages 167–247. Reidel, Dordrecht, 1984.
20. M. Wessel. Obstacles on the way to qualitative spatial reasoning with description
logics: Some undecidability results. In Description Logics 2001.
14Appendix: an example
Example 2. Let MOD = {0, 1, 2}. Consider the grammar logic L with the in-clusion axioms [0]ϕ ⊃ ϕ and [i]ϕ ⊃ [j][k]ϕ if i = (j + k) mod 3. This is aregular grammar logic because the corresponding grammar is regular. We haveAi = MOD, MOD, {0}, δ, {i} for i ∈ MOD, where δ = {(j, k, l) | j, k, l ∈{0, 1, 2} and l = (j + k) mod 3}.
We give a closed CL-tableau for X = { 0 p, [0](¬p∨ 1 q), [1](¬q∨ 2 r), [0]¬r},
in which principal formulae of nodes are underlined. The arrows stand for ruleapplications and are annotated with the rule name. The labels Ri for i ∈ {0, 1, 2}to the right of the arrows marked with (trans)-rule applications stand for the labelon the associated edges in the underlying model being explored by the tableau.
0 p; [0](¬p ∨ 1 q); [1](¬q ∨ 2 r); [0]¬r
3 x (label)

0 p; (A0, {0}): (¬p ∨ 1 q); (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r
(trans)
R0

p; (A0, {0}): (¬p ∨ 1 q); (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r
(add)

p; (A0, {0}): (¬p ∨ 1 q); ¬p ∨ 1 q; (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r
f
f
f
f
(∨)
f
f
f
f
f
f
f
f
f
(∨)
f
f
f
f
f
f
f
f
f

f
f

ssf
p; ¬p; . . .
p;
1 q; (A0, {0}): (¬p ∨ 1 q); (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r
(⊥)
(trans)
R1


⊥
q; (A0, {1}): (¬p ∨ 1 q); (A1, {1}): (¬q ∨ 2 r); (A0, {1}): ¬r
(add)

q; (A0, {1}): (¬p ∨ 1 q); (A1, {1}): (¬q ∨ 2 r); ¬q ∨ 2 r; (A0, {1}): ¬r
f
f
f
f
(∨)
f
f
f
f
f
f
f
f
(∨)
f
f
f
f
f
f
f
f
ss
f

f

f
f
f
q; ¬q; . . .
q;
2 r; (A0, {1}): (¬p ∨ 1 q); (A1, {1}): (¬q ∨ 2 r); (A0, {1}): ¬r
(⊥)
(trans)
R2


⊥
r; (A0, {0}): (¬p ∨ 1 q); (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r
(add)

r; (A0, {0}): (¬p ∨ 1 q); (A1, {0}): (¬q ∨ 2 r); (A0, {0}): ¬r; ¬r
(⊥)

⊥
15
